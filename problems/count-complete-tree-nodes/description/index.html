<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Count Complete Tree Nodes - LeetCodee Solution</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body class="bg-gray-100">
    <header class="bg-gray-800 text-white p-4">
        <div class="container mx-auto">
            <a href="/" class="text-xl font-bold">LeetCodee</a>
        </div>
    </header>

    <main class="container mx-auto p-4">
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h1 class="text-3xl font-bold mb-4">222. Count Complete Tree Nodes</h1>

            <div class="solution-nav mb-6">
                Jump to Solution:
                <a href="#python" class="ml-2 text-blue-600 hover:text-blue-800">Python</a>
                <a href="#java" class="ml-2 text-blue-600 hover:text-blue-800">Java</a>
                <a href="#cpp" class="ml-2 text-blue-600 hover:text-blue-800">C++</a>
                <a href="#javascript" class="ml-2 text-blue-600 hover:text-blue-800">JavaScript</a>
                <a href="#csharp" class="ml-2 text-blue-600 hover:text-blue-800">C#</a>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Problem Description</h2>
                <p class="text-gray-700 mb-4">
                    Given the <code class="bg-gray-100 px-1 rounded">root</code> of a complete binary tree, return the number of nodes in the tree.
                </p>
                <p class="text-gray-700 mb-4">
                    According to <a href="http://en.wikipedia.org/wiki/Binary_tree#Types_of_binary_trees" class="text-blue-600 hover:text-blue-800">Wikipedia</a>, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2<sup>h</sup> nodes inclusive at the last level h.
                </p>
                <p class="text-gray-700 mb-4">
                    Design an algorithm that runs in less than O(n) time complexity.
                </p>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 1:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: root = [1,2,3,4,5,6]
Output: 6</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 2:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: root = []
Output: 0</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 3:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: root = [1]
Output: 1</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Constraints:</h2>
                <ul class="list-disc list-inside text-gray-700">
                    <li>The number of nodes in the tree is in the range <code class="bg-gray-100 px-1 rounded">[0, 5 * 10^4]</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">0 <= Node.val <= 5 * 10^4</code></li>
                    <li>The tree is guaranteed to be complete</li>
                </ul>
            </div>
        </div>

        <!-- Solution Section -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4">Solution</h2>
            
            <!-- Python Solution -->
            <div id="python" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Python Solution</h3>
                <pre class="language-python"><code>class Solution:
    def countNodes(self, root: Optional[TreeNode]) -> int:
        if not root:
            return 0
            
        # Get the height of left and right subtree
        left_height = self.getLeftHeight(root)
        right_height = self.getRightHeight(root)
        
        # If heights are equal, use formula 2^h - 1
        if left_height == right_height:
            return (1 << left_height) - 1
            
        # Otherwise, recursively count nodes
        return 1 + self.countNodes(root.left) + self.countNodes(root.right)
        
    def getLeftHeight(self, node):
        height = 0
        while node:
            height += 1
            node = node.left
        return height
        
    def getRightHeight(self, node):
        height = 0
        while node:
            height += 1
            node = node.right
        return height</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(log²n)</h4>
                    <p class="text-gray-700">We traverse down the tree O(log n) times, and at each step we calculate heights which takes O(log n).</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(log n)</h4>
                    <p class="text-gray-700">Due to the recursion stack.</p>
                </div>
            </div>

            <!-- Java Solution -->
            <div id="java" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Java Solution</h3>
                <pre class="language-java"><code>class Solution {
    public int countNodes(TreeNode root) {
        if (root == null) {
            return 0;
        }
        
        // Get the height of left and right subtree
        int leftHeight = getLeftHeight(root);
        int rightHeight = getRightHeight(root);
        
        // If heights are equal, use formula 2^h - 1
        if (leftHeight == rightHeight) {
            return (1 << leftHeight) - 1;
        }
        
        // Otherwise, recursively count nodes
        return 1 + countNodes(root.left) + countNodes(root.right);
    }
    
    private int getLeftHeight(TreeNode node) {
        int height = 0;
        while (node != null) {
            height++;
            node = node.left;
        }
        return height;
    }
    
    private int getRightHeight(TreeNode node) {
        int height = 0;
        while (node != null) {
            height++;
            node = node.right;
        }
        return height;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(log²n)</h4>
                    <p class="text-gray-700">We traverse down the tree O(log n) times, and at each step we calculate heights which takes O(log n).</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(log n)</h4>
                    <p class="text-gray-700">Due to the recursion stack.</p>
                </div>
            </div>

            <!-- C++ Solution -->
            <div id="cpp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C++ Solution</h3>
                <pre class="language-cpp"><code>class Solution {
public:
    int countNodes(TreeNode* root) {
        if (!root) {
            return 0;
        }
        
        // Get the height of left and right subtree
        int leftHeight = getLeftHeight(root);
        int rightHeight = getRightHeight(root);
        
        // If heights are equal, use formula 2^h - 1
        if (leftHeight == rightHeight) {
            return (1 << leftHeight) - 1;
        }
        
        // Otherwise, recursively count nodes
        return 1 + countNodes(root->left) + countNodes(root->right);
    }
    
private:
    int getLeftHeight(TreeNode* node) {
        int height = 0;
        while (node) {
            height++;
            node = node->left;
        }
        return height;
    }
    
    int getRightHeight(TreeNode* node) {
        int height = 0;
        while (node) {
            height++;
            node = node->right;
        }
        return height;
    }
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(log²n)</h4>
                    <p class="text-gray-700">We traverse down the tree O(log n) times, and at each step we calculate heights which takes O(log n).</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(log n)</h4>
                    <p class="text-gray-700">Due to the recursion stack.</p>
                </div>
            </div>

            <!-- JavaScript Solution -->
            <div id="javascript" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">JavaScript Solution</h3>
                <pre class="language-javascript"><code>/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number}
 */
var countNodes = function(root) {
    if (!root) {
        return 0;
    }
    
    // Get the height of left and right subtree
    const leftHeight = getLeftHeight(root);
    const rightHeight = getRightHeight(root);
    
    // If heights are equal, use formula 2^h - 1
    if (leftHeight === rightHeight) {
        return (1 << leftHeight) - 1;
    }
    
    // Otherwise, recursively count nodes
    return 1 + countNodes(root.left) + countNodes(root.right);
};

function getLeftHeight(node) {
    let height = 0;
    while (node) {
        height++;
        node = node.left;
    }
    return height;
}

function getRightHeight(node) {
    let height = 0;
    while (node) {
        height++;
        node = node.right;
    }
    return height;
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(log²n)</h4>
                    <p class="text-gray-700">We traverse down the tree O(log n) times, and at each step we calculate heights which takes O(log n).</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(log n)</h4>
                    <p class="text-gray-700">Due to the recursion stack.</p>
                </div>
            </div>

            <!-- C# Solution -->
            <div id="csharp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C# Solution</h3>
                <pre class="language-csharp"><code>public class Solution {
    public int CountNodes(TreeNode root) {
        if (root == null) {
            return 0;
        }
        
        // Get the height of left and right subtree
        int leftHeight = GetLeftHeight(root);
        int rightHeight = GetRightHeight(root);
        
        // If heights are equal, use formula 2^h - 1
        if (leftHeight == rightHeight) {
            return (1 << leftHeight) - 1;
        }
        
        // Otherwise, recursively count nodes
        return 1 + CountNodes(root.left) + CountNodes(root.right);
    }
    
    private int GetLeftHeight(TreeNode node) {
        int height = 0;
        while (node != null) {
            height++;
            node = node.left;
        }
        return height;
    }
    
    private int GetRightHeight(TreeNode node) {
        int height = 0;
        while (node != null) {
            height++;
            node = node.right;
        }
        return height;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(log²n)</h4>
                    <p class="text-gray-700">We traverse down the tree O(log n) times, and at each step we calculate heights which takes O(log n).</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(log n)</h4>
                    <p class="text-gray-700">Due to the recursion stack.</p>
                </div>
            </div>
        </div>

        <!-- Approach Explanation -->
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h2 class="text-2xl font-bold mb-4">Approach Explanation</h2>
            
            <div class="space-y-4">
                <p class="text-gray-700">
                    The solution takes advantage of the properties of a complete binary tree to achieve better than O(n) time complexity. Here's how it works:
                </p>
                
                <ol class="list-decimal list-inside text-gray-700 ml-4">
                    <li>For a complete binary tree:
                        <ul class="list-disc list-inside ml-8">
                            <li>If the left and right subtree heights are equal, the tree is a perfect binary tree</li>
                            <li>For a perfect binary tree of height h, we can calculate the number of nodes using the formula 2^h - 1</li>
                            <li>If the heights are not equal, we need to recursively count nodes in both subtrees</li>
                        </ul>
                    </li>
                    <li>The algorithm:
                        <ul class="list-disc list-inside ml-8">
                            <li>Calculate the height of the leftmost path and rightmost path</li>
                            <li>If they're equal, use the formula 2^h - 1</li>
                            <li>Otherwise, recursively count nodes in left and right subtrees</li>
                        </ul>
                    </li>
                </ol>

                <p class="text-gray-700 mt-4">
                    The key insight is that we don't need to visit every node. By checking if subtrees are perfect binary trees,
                    we can calculate their node count in O(1) time using the formula. This leads to a time complexity of O(log²n)
                    instead of O(n).
                </p>
            </div>
        </div>
    </main>

    <footer class="bg-gray-800 text-white p-4 mt-8">
        <div class="container mx-auto text-center">
            <p>© 2024 LeetCodee. All rights reserved.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html> 