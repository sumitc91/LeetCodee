<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lowest Common Ancestor of a Binary Search Tree - LeetCodee Solution</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body class="bg-gray-100">
    <header class="bg-gray-800 text-white p-4">
        <div class="container mx-auto">
            <a href="/" class="text-xl font-bold">LeetCodee</a>
        </div>
    </header>

    <main class="container mx-auto p-4">
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h1 class="text-3xl font-bold mb-4">235. Lowest Common Ancestor of a Binary Search Tree</h1>

            <div class="solution-nav mb-6">
                Jump to Solution:
                <a href="#python" class="ml-2 text-blue-600 hover:text-blue-800">Python</a>
                <a href="#java" class="ml-2 text-blue-600 hover:text-blue-800">Java</a>
                <a href="#cpp" class="ml-2 text-blue-600 hover:text-blue-800">C++</a>
                <a href="#javascript" class="ml-2 text-blue-600 hover:text-blue-800">JavaScript</a>
                <a href="#csharp" class="ml-2 text-blue-600 hover:text-blue-800">C#</a>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Problem Description</h2>
                <p class="text-gray-700 mb-4">
                    Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.
                </p>
                <p class="text-gray-700 mb-4">
                    According to the definition of LCA on Wikipedia: "The lowest common ancestor is defined between two nodes <code class="bg-gray-100 px-1 rounded">p</code> and <code class="bg-gray-100 px-1 rounded">q</code> as the lowest node in <code class="bg-gray-100 px-1 rounded">T</code> that has both <code class="bg-gray-100 px-1 rounded">p</code> and <code class="bg-gray-100 px-1 rounded">q</code> as descendants (where we allow a node to be a descendant of itself)."
                </p>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 1:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 2:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Constraints:</h2>
                <ul class="list-disc list-inside text-gray-700">
                    <li>The number of nodes in the tree is in the range <code class="bg-gray-100 px-1 rounded">[2, 10⁵]</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">-10⁹ <= Node.val <= 10⁹</code></li>
                    <li>All <code class="bg-gray-100 px-1 rounded">Node.val</code> are unique</li>
                    <li><code class="bg-gray-100 px-1 rounded">p != q</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">p</code> and <code class="bg-gray-100 px-1 rounded">q</code> will exist in the BST</li>
                </ul>
            </div>
        </div>

        <!-- Solution Section -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4">Solution</h2>
            
            <!-- Python Solution -->
            <div id="python" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Python Solution</h3>
                <pre class="language-python"><code># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        # If both p and q are greater than root, LCA is in right subtree
        if p.val > root.val and q.val > root.val:
            return self.lowestCommonAncestor(root.right, p, q)
        
        # If both p and q are smaller than root, LCA is in left subtree
        if p.val < root.val and q.val < root.val:
            return self.lowestCommonAncestor(root.left, p, q)
        
        # If one is smaller and one is greater, or one equals root,
        # then current root is the LCA
        return root</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(h)</h4>
                    <p class="text-gray-700">Where h is the height of the tree. In the worst case, we might need to traverse from root to leaf.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(h)</h4>
                    <p class="text-gray-700">Due to the recursive call stack. For a balanced BST, h = log(n).</p>
                </div>
            </div>

            <!-- Java Solution -->
            <div id="java" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Java Solution</h3>
                <pre class="language-java"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // If both p and q are greater than root, LCA is in right subtree
        if (p.val > root.val && q.val > root.val) {
            return lowestCommonAncestor(root.right, p, q);
        }
        
        // If both p and q are smaller than root, LCA is in left subtree
        if (p.val < root.val && q.val < root.val) {
            return lowestCommonAncestor(root.left, p, q);
        }
        
        // If one is smaller and one is greater, or one equals root,
        // then current root is the LCA
        return root;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(h)</h4>
                    <p class="text-gray-700">Where h is the height of the tree. In the worst case, we might need to traverse from root to leaf.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(h)</h4>
                    <p class="text-gray-700">Due to the recursive call stack. For a balanced BST, h = log(n).</p>
                </div>
            </div>

            <!-- C++ Solution -->
            <div id="cpp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C++ Solution</h3>
                <pre class="language-cpp"><code>/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        // If both p and q are greater than root, LCA is in right subtree
        if (p->val > root->val && q->val > root->val) {
            return lowestCommonAncestor(root->right, p, q);
        }
        
        // If both p and q are smaller than root, LCA is in left subtree
        if (p->val < root->val && q->val < root->val) {
            return lowestCommonAncestor(root->left, p, q);
        }
        
        // If one is smaller and one is greater, or one equals root,
        // then current root is the LCA
        return root;
    }
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(h)</h4>
                    <p class="text-gray-700">Where h is the height of the tree. In the worst case, we might need to traverse from root to leaf.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(h)</h4>
                    <p class="text-gray-700">Due to the recursive call stack. For a balanced BST, h = log(n).</p>
                </div>
            </div>

            <!-- JavaScript Solution -->
            <div id="javascript" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">JavaScript Solution</h3>
                <pre class="language-javascript"><code>/**
 * Definition for a binary tree node.
 * function TreeNode(val) {
 *     this.val = val;
 *     this.left = this.right = null;
 * }
 */
/**
 * @param {TreeNode} root
 * @param {TreeNode} p
 * @param {TreeNode} q
 * @return {TreeNode}
 */
var lowestCommonAncestor = function(root, p, q) {
    // If both p and q are greater than root, LCA is in right subtree
    if (p.val > root.val && q.val > root.val) {
        return lowestCommonAncestor(root.right, p, q);
    }
    
    // If both p and q are smaller than root, LCA is in left subtree
    if (p.val < root.val && q.val < root.val) {
        return lowestCommonAncestor(root.left, p, q);
    }
    
    // If one is smaller and one is greater, or one equals root,
    // then current root is the LCA
    return root;
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(h)</h4>
                    <p class="text-gray-700">Where h is the height of the tree. In the worst case, we might need to traverse from root to leaf.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(h)</h4>
                    <p class="text-gray-700">Due to the recursive call stack. For a balanced BST, h = log(n).</p>
                </div>
            </div>

            <!-- C# Solution -->
            <div id="csharp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C# Solution</h3>
                <pre class="language-csharp"><code>/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     public int val;
 *     public TreeNode left;
 *     public TreeNode right;
 *     public TreeNode(int x) { val = x; }
 * }
 */
public class Solution {
    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        // If both p and q are greater than root, LCA is in right subtree
        if (p.val > root.val && q.val > root.val) {
            return LowestCommonAncestor(root.right, p, q);
        }
        
        // If both p and q are smaller than root, LCA is in left subtree
        if (p.val < root.val && q.val < root.val) {
            return LowestCommonAncestor(root.left, p, q);
        }
        
        // If one is smaller and one is greater, or one equals root,
        // then current root is the LCA
        return root;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(h)</h4>
                    <p class="text-gray-700">Where h is the height of the tree. In the worst case, we might need to traverse from root to leaf.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(h)</h4>
                    <p class="text-gray-700">Due to the recursive call stack. For a balanced BST, h = log(n).</p>
                </div>
            </div>
        </div>

        <!-- Approach Explanation -->
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h2 class="text-2xl font-bold mb-4">Approach Explanation</h2>
            
            <div class="space-y-4">
                <p class="text-gray-700">
                    The solution leverages the properties of a Binary Search Tree to efficiently find the LCA:
                </p>
                
                <ol class="list-decimal list-inside text-gray-700 ml-4">
                    <li>BST Property:
                        <ul class="list-disc list-inside ml-8">
                            <li>All nodes in left subtree are smaller than root</li>
                            <li>All nodes in right subtree are greater than root</li>
                            <li>Both subtrees are also BSTs</li>
                        </ul>
                    </li>
                    <li>Algorithm Steps:
                        <ul class="list-disc list-inside ml-8">
                            <li>Compare both p and q with current root</li>
                            <li>If both are greater, go right</li>
                            <li>If both are smaller, go left</li>
                            <li>If split occurs or equals root, we found LCA</li>
                        </ul>
                    </li>
                </ol>

                <p class="text-gray-700 mt-4">
                    Example walkthrough for [6,2,8,0,4,7,9] with p=2 and q=8:
                    <ul class="list-disc list-inside ml-4">
                        <li>Start at root (6)</li>
                        <li>2 < 6 < 8 (split occurs)</li>
                        <li>Therefore, 6 is the LCA</li>
                    </ul>
                </p>

                <p class="text-gray-700 mt-4">
                    Key insights:
                    <ul class="list-disc list-inside ml-4">
                        <li>BST property makes search efficient</li>
                        <li>No need to store parent pointers</li>
                        <li>Works for both nearby and distant nodes</li>
                        <li>Recursive solution is concise and elegant</li>
                    </ul>
                </p>
            </div>
        </div>
    </main>

    <footer class="bg-gray-800 text-white p-4 mt-8">
        <div class="container mx-auto text-center">
            <p>© 2024 LeetCodee. All rights reserved.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html> 