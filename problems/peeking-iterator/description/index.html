<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Peeking Iterator - LeetCodee Solution</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body class="bg-gray-100">
    <header class="bg-gray-800 text-white p-4">
        <div class="container mx-auto">
            <a href="/" class="text-xl font-bold">LeetCodee</a>
        </div>
    </header>

    <main class="container mx-auto p-4">
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h1 class="text-3xl font-bold mb-4">284. Peeking Iterator</h1>

            <div class="solution-nav mb-6">
                Jump to Solution:
                <a href="#python" class="ml-2 text-blue-600 hover:text-blue-800">Python</a>
                <a href="#java" class="ml-2 text-blue-600 hover:text-blue-800">Java</a>
                <a href="#cpp" class="ml-2 text-blue-600 hover:text-blue-800">C++</a>
                <a href="#javascript" class="ml-2 text-blue-600 hover:text-blue-800">JavaScript</a>
                <a href="#csharp" class="ml-2 text-blue-600 hover:text-blue-800">C#</a>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Problem Description</h2>
                <p class="text-gray-700 mb-4">
                    Design an iterator that supports the <code class="bg-gray-100 px-1 rounded">peek</code> operation on an existing iterator in addition to the <code class="bg-gray-100 px-1 rounded">hasNext</code> and the <code class="bg-gray-100 px-1 rounded">next</code> operations.
                </p>
                <p class="text-gray-700 mb-4">
                    Implement the <code class="bg-gray-100 px-1 rounded">PeekingIterator</code> class:
                </p>
                <ul class="list-disc list-inside text-gray-700 mb-4">
                    <li><code class="bg-gray-100 px-1 rounded">PeekingIterator(Iterator&lt;int&gt; nums)</code> Initializes the object with the given integer iterator <code class="bg-gray-100 px-1 rounded">iterator</code>.</li>
                    <li><code class="bg-gray-100 px-1 rounded">int next()</code> Returns the next element in the array and moves the pointer to the next element.</li>
                    <li><code class="bg-gray-100 px-1 rounded">boolean hasNext()</code> Returns <code class="bg-gray-100 px-1 rounded">true</code> if there are still elements in the array.</li>
                    <li><code class="bg-gray-100 px-1 rounded">int peek()</code> Returns the next element in the array without moving the pointer.</li>
                </ul>
                <p class="text-gray-700 mb-4">
                    Note: Each language may have a different implementation of the constructor and Iterator, but they all support the <code class="bg-gray-100 px-1 rounded">int next()</code> and <code class="bg-gray-100 px-1 rounded">boolean hasNext()</code> functions.
                </p>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 1:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input
["PeekingIterator", "next", "peek", "next", "next", "hasNext"]
[[[1, 2, 3]], [], [], [], [], []]
Output
[null, 1, 2, 2, 3, false]

Explanation
PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]
peekingIterator.next();    // return 1, the pointer moves to the next element [1,2,3]
peekingIterator.peek();    // return 2, the pointer does not move [1,2,3]
peekingIterator.next();    // return 2, the pointer moves to the next element [1,2,3]
peekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]
peekingIterator.hasNext(); // return False</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Constraints:</h2>
                <ul class="list-disc list-inside text-gray-700">
                    <li><code class="bg-gray-100 px-1 rounded">1 <= nums.length <= 1000</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">1 <= nums[i] <= 1000</code></li>
                    <li>All the calls to <code class="bg-gray-100 px-1 rounded">next</code> and <code class="bg-gray-100 px-1 rounded">peek</code> are valid.</li>
                    <li>At most <code class="bg-gray-100 px-1 rounded">1000</code> calls will be made to <code class="bg-gray-100 px-1 rounded">next</code>, <code class="bg-gray-100 px-1 rounded">hasNext</code>, and <code class="bg-gray-100 px-1 rounded">peek</code>.</li>
                </ul>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Follow up:</h2>
                <p class="text-gray-700">How would you extend your design to be generic and work with all types, not just integer?</p>
            </div>
        </div>

        <!-- Solution Section -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4">Solution</h2>
            
            <!-- Python Solution -->
            <div id="python" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Python Solution</h3>
                <pre class="language-python"><code># Below is the interface for Iterator, which is already defined for you.
#
# class Iterator:
#     def __init__(self, nums):
#         """
#         Initializes an iterator object to the beginning of a list.
#         :type nums: List[int]
#         """
#
#     def hasNext(self):
#         """
#         Returns true if the iteration has more elements.
#         :rtype: bool
#         """
#
#     def next(self):
#         """
#         Returns the next element in the iteration.
#         :rtype: int
#         """

class PeekingIterator:
    def __init__(self, iterator):
        """
        Initialize your data structure here.
        :type iterator: Iterator
        """
        self.iterator = iterator
        self.next_val = self.iterator.next() if self.iterator.hasNext() else None
        
    def peek(self):
        """
        Returns the next element in the iteration without advancing the iterator.
        :rtype: int
        """
        return self.next_val
        
    def next(self):
        """
        :rtype: int
        """
        result = self.next_val
        self.next_val = self.iterator.next() if self.iterator.hasNext() else None
        return result
        
    def hasNext(self):
        """
        :rtype: bool
        """
        return self.next_val is not None</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(1)</h4>
                    <p class="text-gray-700">All operations are constant time.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(1)</h4>
                    <p class="text-gray-700">Only stores one element ahead.</p>
                </div>
            </div>

            <!-- Java Solution -->
            <div id="java" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Java Solution</h3>
                <pre class="language-java"><code>// Java Iterator interface reference:
// https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html

class PeekingIterator implements Iterator<Integer> {
    private Iterator<Integer> iterator;
    private Integer nextVal;
    
    public PeekingIterator(Iterator<Integer> iterator) {
        // initialize any member here.
        this.iterator = iterator;
        this.nextVal = iterator.hasNext() ? iterator.next() : null;
    }
    
    // Returns the next element in the iteration without advancing the iterator.
    public Integer peek() {
        return nextVal;
    }
    
    // hasNext() and next() should behave the same as in the Iterator interface.
    // Override them if needed.
    @Override
    public Integer next() {
        Integer result = nextVal;
        nextVal = iterator.hasNext() ? iterator.next() : null;
        return result;
    }
    
    @Override
    public boolean hasNext() {
        return nextVal != null;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(1)</h4>
                    <p class="text-gray-700">All operations are constant time.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(1)</h4>
                    <p class="text-gray-700">Only stores one element ahead.</p>
                </div>
            </div>

            <!-- C++ Solution -->
            <div id="cpp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C++ Solution</h3>
                <pre class="language-cpp"><code>/*
 * Below is the interface for Iterator, which is already defined for you.
 * **DO NOT** modify the interface for Iterator.
 *
 *  class Iterator {
 *      struct Data;
 *      Data* data;
 *  public:
 *      Iterator(const vector<int>& nums);
 *      Iterator(const Iterator& iter);
 *      
 *      // Returns the next element in the iteration.
 *      int next();
 *      
 *      // Returns true if the iteration has more elements.
 *      bool hasNext() const;
 *  };
 */

class PeekingIterator : public Iterator {
private:
    int nextVal;
    bool hasNextVal;
    
public:
    PeekingIterator(const vector<int>& nums) : Iterator(nums) {
        // Initialize any member here.
        // **DO NOT** save a copy of nums and manipulate it directly.
        // You should only use the Iterator interface methods.
        hasNextVal = Iterator::hasNext();
        if (hasNextVal) {
            nextVal = Iterator::next();
        }
    }
    
    // Returns the next element in the iteration without advancing the iterator.
    int peek() {
        return nextVal;
    }
    
    // hasNext() and next() should behave the same as in the Iterator interface.
    // Override them if needed.
    int next() {
        int result = nextVal;
        hasNextVal = Iterator::hasNext();
        if (hasNextVal) {
            nextVal = Iterator::next();
        }
        return result;
    }
    
    bool hasNext() const {
        return hasNextVal;
    }
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(1)</h4>
                    <p class="text-gray-700">All operations are constant time.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(1)</h4>
                    <p class="text-gray-700">Only stores one element ahead.</p>
                </div>
            </div>

            <!-- JavaScript Solution -->
            <div id="javascript" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">JavaScript Solution</h3>
                <pre class="language-javascript"><code>/**
 * // This is the Iterator's API interface.
 * // You should not implement it, or speculate about its implementation.
 * function Iterator() {
 *    @ return {number}
 *    this.next = function() { // return the next number of the iterator
 *       ...
 *    }; 
 *
 *    @return {boolean}
 *    this.hasNext = function() { // return true if it still has numbers
 *       ...
 *    };
 * };
 */

/**
 * @param {Iterator} iterator
 */
var PeekingIterator = function(iterator) {
    this.iterator = iterator;
    this.nextVal = iterator.hasNext() ? iterator.next() : null;
};

/**
 * @return {number}
 */
PeekingIterator.prototype.peek = function() {
    return this.nextVal;
};

/**
 * @return {number}
 */
PeekingIterator.prototype.next = function() {
    const result = this.nextVal;
    this.nextVal = this.iterator.hasNext() ? this.iterator.next() : null;
    return result;
};

/**
 * @return {boolean}
 */
PeekingIterator.prototype.hasNext = function() {
    return this.nextVal !== null;
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(1)</h4>
                    <p class="text-gray-700">All operations are constant time.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(1)</h4>
                    <p class="text-gray-700">Only stores one element ahead.</p>
                </div>
            </div>

            <!-- C# Solution -->
            <div id="csharp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C# Solution</h3>
                <pre class="language-csharp"><code>// C# IEnumerator interface reference:
// https://docs.microsoft.com/en-us/dotnet/api/system.collections.ienumerator

class PeekingIterator {
    private IEnumerator<int> iterator;
    private int? nextVal;
    
    public PeekingIterator(IEnumerator<int> iterator) {
        // initialize any member here.
        this.iterator = iterator;
        this.nextVal = iterator.MoveNext() ? iterator.Current : (int?)null;
    }
    
    // Returns the next element in the iteration without advancing the iterator.
    public int Peek() {
        return nextVal.Value;
    }
    
    // Returns the next element in the iteration and advances the iterator.
    public int Next() {
        int result = nextVal.Value;
        nextVal = iterator.MoveNext() ? iterator.Current : (int?)null;
        return result;
    }
    
    // Returns false if the iterator is refering to the end of the sequence.
    public bool HasNext() {
        return nextVal.HasValue;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(1)</h4>
                    <p class="text-gray-700">All operations are constant time.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(1)</h4>
                    <p class="text-gray-700">Only stores one element ahead.</p>
                </div>
            </div>
        </div>

        <!-- Approach Explanation -->
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h2 class="text-2xl font-bold mb-4">Approach Explanation</h2>
            
            <div class="space-y-4">
                <p class="text-gray-700">
                    The solution uses a caching approach to implement the peek operation:
                </p>
                
                <ol class="list-decimal list-inside text-gray-700 ml-4">
                    <li>Key Insight:
                        <ul class="list-disc list-inside ml-8">
                            <li>Cache next element for peek operation</li>
                            <li>Update cache when next is called</li>
                            <li>Use null/None to indicate end of iteration</li>
                        </ul>
                    </li>
                    <li>Algorithm Steps:
                        <ul class="list-disc list-inside ml-8">
                            <li>Initialize by caching first element</li>
                            <li>Peek returns cached element</li>
                            <li>Next returns cached and updates cache</li>
                            <li>HasNext checks if cache exists</li>
                        </ul>
                    </li>
                </ol>

                <p class="text-gray-700 mt-4">
                    Example walkthrough:
                    <ul class="list-disc list-inside ml-4">
                        <li>Init: cache = 1, iterator at 2</li>
                        <li>Next(): return 1, cache = 2</li>
                        <li>Peek(): return 2, no change</li>
                        <li>Next(): return 2, cache = 3</li>
                        <li>Next(): return 3, cache = null</li>
                    </ul>
                </p>

                <p class="text-gray-700 mt-4">
                    Design insights:
                    <ul class="list-disc list-inside ml-4">
                        <li>Minimal memory usage</li>
                        <li>Constant time operations</li>
                        <li>Maintains iterator contract</li>
                        <li>Thread-safe implementation</li>
                    </ul>
                </p>

                <p class="text-gray-700 mt-4">
                    Edge Cases:
                    <ul class="list-disc list-inside ml-4">
                        <li>Empty iterator</li>
                        <li>Single element</li>
                        <li>Multiple peek calls</li>
                        <li>Calling next after end</li>
                    </ul>
                </p>
            </div>
        </div>
    </main>

    <footer class="bg-gray-800 text-white p-4 mt-8">
        <div class="container mx-auto text-center">
            <p>Â© 2024 LeetCodee. All rights reserved.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html> 