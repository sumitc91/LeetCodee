<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LRU Cache - LeetCodee</title>
    <meta name="description" content="Detailed solution explanation for LeetCode problem 146: LRU Cache. Solutions in Python, Java, C++, JavaScript, and C#.">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        header {
            background-color: #1a1a1a;
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        header h1 {
            margin: 0;
            color: #ffa116;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .difficulty {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 14px;
            margin-right: 10px;
        }
        .medium { background-color: #FFB800; color: #1a1a1a; }
        pre {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
        }
        code {
            font-family: 'Consolas', 'Monaco', monospace;
        }
        .solution-nav {
            margin: 20px 0;
            padding: 10px;
            background-color: #f8f8f8;
            border-radius: 4px;
        }
        .solution-nav a {
            margin-right: 15px;
            color: #0066cc;
            text-decoration: none;
        }
        .solution-nav a:hover {
            text-decoration: underline;
        }
        .solution {
            margin-top: 20px;
        }
        .complexity {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f8f8;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <header>
        <h1>146. LRU Cache</h1>
        <span class="difficulty medium">Medium</span>
    </header>

    <div class="content">
        <h2>Problem Description</h2>
        <p>Design a data structure that follows the constraints of a <strong>Least Recently Used (LRU) cache</strong>.</p>
        <p>Implement the <code>LRUCache</code> class:</p>
        <ul>
            <li><code>LRUCache(int capacity)</code> Initialize the LRU cache with <strong>positive</strong> size <code>capacity</code>.</li>
            <li><code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>.</li>
            <li><code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, <strong>evict</strong> the least recently used key.</li>
        </ul>
        <p>The functions <code>get</code> and <code>put</code> must each run in <code>O(1)</code> average time complexity.</p>

        <h3>Examples</h3>
        <pre>
Input
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
Output
[null, null, null, 1, null, -1, null, -1, 3, 4]

Explanation
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // cache is {1=1}
lRUCache.put(2, 2); // cache is {1=1, 2=2}
lRUCache.get(1);    // return 1
lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}
lRUCache.get(2);    // returns -1 (not found)
lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}
lRUCache.get(1);    // return -1 (not found)
lRUCache.get(3);    // return 3
lRUCache.get(4);    // return 4</pre>

        <div class="solution-nav">
            Jump to Solution:
            <a href="#python">Python</a>
            <a href="#java">Java</a>
            <a href="#cpp">C++</a>
            <a href="#javascript">JavaScript</a>
            <a href="#csharp">C#</a>
        </div>

        <div class="solution" id="python">
            <h3>Python Solution</h3>
            <pre><code>
class Node:
    def __init__(self, key=0, value=0):
        self.key = key
        self.value = value
        self.prev = None
        self.next = None

class LRUCache:
    def __init__(self, capacity: int):
        self.capacity = capacity
        self.cache = {}
        self.head = Node()
        self.tail = Node()
        self.head.next = self.tail
        self.tail.prev = self.head
    
    def _remove(self, node):
        node.prev.next = node.next
        node.next.prev = node.prev
    
    def _add(self, node):
        node.prev = self.head
        node.next = self.head.next
        self.head.next.prev = node
        self.head.next = node
    
    def get(self, key: int) -> int:
        if key in self.cache:
            node = self.cache[key]
            self._remove(node)
            self._add(node)
            return node.value
        return -1
    
    def put(self, key: int, value: int) -> None:
        if key in self.cache:
            self._remove(self.cache[key])
        node = Node(key, value)
        self._add(node)
        self.cache[key] = node
        if len(self.cache) > self.capacity:
            lru = self.tail.prev
            self._remove(lru)
            del self.cache[lru.key]</code></pre>
        </div>

        <div class="solution" id="java">
            <h3>Java Solution</h3>
            <pre><code>
class LRUCache {
    class Node {
        int key;
        int value;
        Node prev;
        Node next;
        
        Node(int key, int value) {
            this.key = key;
            this.value = value;
        }
    }
    
    private int capacity;
    private Map<Integer, Node> cache;
    private Node head;
    private Node tail;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new HashMap<>();
        this.head = new Node(0, 0);
        this.tail = new Node(0, 0);
        head.next = tail;
        tail.prev = head;
    }
    
    private void remove(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    private void add(Node node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }
    
    public int get(int key) {
        if (cache.containsKey(key)) {
            Node node = cache.get(key);
            remove(node);
            add(node);
            return node.value;
        }
        return -1;
    }
    
    public void put(int key, int value) {
        if (cache.containsKey(key)) {
            remove(cache.get(key));
        }
        Node node = new Node(key, value);
        add(node);
        cache.put(key, node);
        if (cache.size() > capacity) {
            Node lru = tail.prev;
            remove(lru);
            cache.remove(lru.key);
        }
    }
}</code></pre>
        </div>

        <div class="solution" id="cpp">
            <h3>C++ Solution</h3>
            <pre><code>
class LRUCache {
    struct Node {
        int key;
        int value;
        Node* prev;
        Node* next;
        Node(int k = 0, int v = 0) : key(k), value(v), prev(nullptr), next(nullptr) {}
    };
    
    int capacity;
    unordered_map<int, Node*> cache;
    Node* head;
    Node* tail;
    
    void remove(Node* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }
    
    void add(Node* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }
    
public:
    LRUCache(int capacity) : capacity(capacity) {
        head = new Node();
        tail = new Node();
        head->next = tail;
        tail->prev = head;
    }
    
    ~LRUCache() {
        while (head) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
    }
    
    int get(int key) {
        if (cache.count(key)) {
            Node* node = cache[key];
            remove(node);
            add(node);
            return node->value;
        }
        return -1;
    }
    
    void put(int key, int value) {
        if (cache.count(key)) {
            remove(cache[key]);
            delete cache[key];
        }
        Node* node = new Node(key, value);
        add(node);
        cache[key] = node;
        if (cache.size() > capacity) {
            Node* lru = tail->prev;
            remove(lru);
            cache.erase(lru->key);
            delete lru;
        }
    }
};</code></pre>
        </div>

        <div class="solution" id="javascript">
            <h3>JavaScript Solution</h3>
            <pre><code>
class Node {
    constructor(key = 0, value = 0) {
        this.key = key;
        this.value = value;
        this.prev = null;
        this.next = null;
    }
}

/**
 * @param {number} capacity
 */
class LRUCache {
    constructor(capacity) {
        this.capacity = capacity;
        this.cache = new Map();
        this.head = new Node();
        this.tail = new Node();
        this.head.next = this.tail;
        this.tail.prev = this.head;
    }
    
    _remove(node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    _add(node) {
        node.prev = this.head;
        node.next = this.head.next;
        this.head.next.prev = node;
        this.head.next = node;
    }
    
    /** 
     * @param {number} key
     * @return {number}
     */
    get(key) {
        if (this.cache.has(key)) {
            const node = this.cache.get(key);
            this._remove(node);
            this._add(node);
            return node.value;
        }
        return -1;
    }
    
    /** 
     * @param {number} key 
     * @param {number} value
     * @return {void}
     */
    put(key, value) {
        if (this.cache.has(key)) {
            this._remove(this.cache.get(key));
        }
        const node = new Node(key, value);
        this._add(node);
        this.cache.set(key, node);
        if (this.cache.size > this.capacity) {
            const lru = this.tail.prev;
            this._remove(lru);
            this.cache.delete(lru.key);
        }
    }
}</code></pre>
        </div>

        <div class="solution" id="csharp">
            <h3>C# Solution</h3>
            <pre><code>
public class LRUCache {
    private class Node {
        public int key;
        public int value;
        public Node prev;
        public Node next;
        
        public Node(int key = 0, int value = 0) {
            this.key = key;
            this.value = value;
        }
    }
    
    private int capacity;
    private Dictionary<int, Node> cache;
    private Node head;
    private Node tail;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.cache = new Dictionary<int, Node>();
        this.head = new Node();
        this.tail = new Node();
        head.next = tail;
        tail.prev = head;
    }
    
    private void Remove(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }
    
    private void Add(Node node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }
    
    public int Get(int key) {
        if (cache.ContainsKey(key)) {
            Node node = cache[key];
            Remove(node);
            Add(node);
            return node.value;
        }
        return -1;
    }
    
    public void Put(int key, int value) {
        if (cache.ContainsKey(key)) {
            Remove(cache[key]);
        }
        Node node = new Node(key, value);
        Add(node);
        cache[key] = node;
        if (cache.Count > capacity) {
            Node lru = tail.prev;
            Remove(lru);
            cache.Remove(lru.key);
        }
    }
}</code></pre>
        </div>

        <div class="complexity">
            <h3>Complexity Analysis</h3>
            <ul>
                <li><strong>Time Complexity:</strong> O(1) for both get and put operations</li>
                <li><strong>Space Complexity:</strong> O(capacity) to store at most capacity + 1 elements</li>
            </ul>
        </div>

        <div class="explanation">
            <h3>Solution Explanation</h3>
            <p>This solution uses a doubly linked list and a hash map:</p>
            <ul>
                <li>Key concept:
                    <ul>
                        <li>Doubly linked list</li>
                        <li>Hash map</li>
                        <li>LRU eviction</li>
                    </ul>
                </li>
                <li>Algorithm steps:
                    <ul>
                        <li>Track usage order</li>
                        <li>Update on access</li>
                        <li>Evict when full</li>
                        <li>Maintain O(1)</li>
                    </ul>
                </li>
            </ul>
            <p>Key points:</p>
            <ul>
                <li>Constant time operations</li>
                <li>Double linking for O(1) removal</li>
                <li>Hash map for O(1) lookup</li>
                <li>Capacity management</li>
            </ul>
        </div>
    </div>
</body>
</html> 