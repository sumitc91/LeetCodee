<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Next Permutation - LeetCodee</title>
    <meta name="description" content="Detailed solution explanation for LeetCode problem 31: Next Permutation. Solutions in Python, Java, C++, JavaScript, and C#.">
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        header {
            background-color: #1a1a1a;
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
        }
        header h1 {
            margin: 0;
            color: #ffa116;
        }
        .content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .difficulty {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 14px;
            margin-right: 10px;
        }
        .medium { background-color: #FFB800; color: #1a1a1a; }
        pre {
            background-color: #f8f8f8;
            padding: 15px;
            border-radius: 4px;
            overflow-x: auto;
        }
        code {
            font-family: 'Consolas', 'Monaco', monospace;
        }
        .solution-nav {
            margin: 20px 0;
            padding: 10px;
            background-color: #f8f8f8;
            border-radius: 4px;
        }
        .solution-nav a {
            margin-right: 15px;
            color: #0066cc;
            text-decoration: none;
        }
        .solution-nav a:hover {
            text-decoration: underline;
        }
        .solution {
            margin-top: 20px;
        }
        .complexity {
            margin-top: 10px;
            padding: 10px;
            background-color: #f8f8f8;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <header>
        <h1>31. Next Permutation</h1>
        <span class="difficulty medium">Medium</span>
    </header>

    <div class="content">
        <h2>Problem Description</h2>
        <p>Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers. If such arrangement is not possible, it must rearrange it as the lowest possible order (i.e., sorted in ascending order).</p>
        <p>The replacement must be in place and use only constant extra memory.</p>

        <h3>Examples</h3>
        <pre>
Example 1:
Input: nums = [1,2,3]
Output: [1,3,2]

Example 2:
Input: nums = [3,2,1]
Output: [1,2,3]

Example 3:
Input: nums = [1,1,5]
Output: [1,5,1]</pre>

        <div class="solution-nav">
            Jump to Solution:
            <a href="#python">Python</a>
            <a href="#java">Java</a>
            <a href="#cpp">C++</a>
            <a href="#javascript">JavaScript</a>
            <a href="#csharp">C#</a>
        </div>

        <div class="solution" id="python">
            <h3>Python Solution</h3>
            <pre><code>
def nextPermutation(nums: List[int]) -> None:
    """
    Do not return anything, modify nums in-place instead.
    """
    # Find first decreasing element from right
    i = len(nums) - 2
    while i >= 0 and nums[i] >= nums[i + 1]:
        i -= 1
        
    if i >= 0:
        # Find number just larger than nums[i]
        j = len(nums) - 1
        while j >= 0 and nums[j] <= nums[i]:
            j -= 1
        nums[i], nums[j] = nums[j], nums[i]
    
    # Reverse the subarray after index i
    left = i + 1
    right = len(nums) - 1
    while left < right:
        nums[left], nums[right] = nums[right], nums[left]
        left += 1
        right -= 1</code></pre>
        </div>

        <div class="solution" id="java">
            <h3>Java Solution</h3>
            <pre><code>
class Solution {
    public void nextPermutation(int[] nums) {
        // Find first decreasing element from right
        int i = nums.length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        
        if (i >= 0) {
            // Find number just larger than nums[i]
            int j = nums.length - 1;
            while (j >= 0 && nums[j] <= nums[i]) {
                j--;
            }
            swap(nums, i, j);
        }
        
        // Reverse the subarray after index i
        reverse(nums, i + 1);
    }
    
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    
    private void reverse(int[] nums, int start) {
        int left = start, right = nums.length - 1;
        while (left < right) {
            swap(nums, left, right);
            left++;
            right--;
        }
    }
}</code></pre>
        </div>

        <div class="solution" id="cpp">
            <h3>C++ Solution</h3>
            <pre><code>
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        // Find first decreasing element from right
        int i = nums.size() - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        
        if (i >= 0) {
            // Find number just larger than nums[i]
            int j = nums.size() - 1;
            while (j >= 0 && nums[j] <= nums[i]) {
                j--;
            }
            swap(nums[i], nums[j]);
        }
        
        // Reverse the subarray after index i
        reverse(nums.begin() + i + 1, nums.end());
    }
};</code></pre>
        </div>

        <div class="solution" id="javascript">
            <h3>JavaScript Solution</h3>
            <pre><code>
/**
 * @param {number[]} nums
 * @return {void} Do not return anything, modify nums in-place instead.
 */
var nextPermutation = function(nums) {
    // Find first decreasing element from right
    let i = nums.length - 2;
    while (i >= 0 && nums[i] >= nums[i + 1]) {
        i--;
    }
    
    if (i >= 0) {
        // Find number just larger than nums[i]
        let j = nums.length - 1;
        while (j >= 0 && nums[j] <= nums[i]) {
            j--;
        }
        [nums[i], nums[j]] = [nums[j], nums[i]];
    }
    
    // Reverse the subarray after index i
    let left = i + 1;
    let right = nums.length - 1;
    while (left < right) {
        [nums[left], nums[right]] = [nums[right], nums[left]];
        left++;
        right--;
    }
};</code></pre>
        </div>

        <div class="solution" id="csharp">
            <h3>C# Solution</h3>
            <pre><code>
public class Solution {
    public void NextPermutation(int[] nums) {
        // Find first decreasing element from right
        int i = nums.Length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        
        if (i >= 0) {
            // Find number just larger than nums[i]
            int j = nums.Length - 1;
            while (j >= 0 && nums[j] <= nums[i]) {
                j--;
            }
            Swap(nums, i, j);
        }
        
        // Reverse the subarray after index i
        Reverse(nums, i + 1);
    }
    
    private void Swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
    
    private void Reverse(int[] nums, int start) {
        int left = start, right = nums.Length - 1;
        while (left < right) {
            Swap(nums, left, right);
            left++;
            right--;
        }
    }
}</code></pre>
        </div>

        <div class="complexity">
            <h3>Complexity Analysis</h3>
            <ul>
                <li><strong>Time Complexity:</strong> O(n) where n is the length of the input array</li>
                <li><strong>Space Complexity:</strong> O(1) as we modify the array in-place</li>
            </ul>
        </div>

        <div class="explanation">
            <h3>Solution Explanation</h3>
            <p>This solution finds the next lexicographically greater permutation. Here's how it works:</p>
            <ul>
                <li>Find the first pair of adjacent numbers from right where nums[i] < nums[i+1]</li>
                <li>If such pair exists:
                    <ul>
                        <li>Find the smallest number greater than nums[i] to its right</li>
                        <li>Swap these numbers</li>
                    </ul>
                </li>
                <li>Reverse all numbers after index i to get the smallest arrangement</li>
            </ul>
            <p>Key points:</p>
            <ul>
                <li>The solution modifies the array in-place</li>
                <li>Uses constant extra space</li>
                <li>Handles all edge cases properly</li>
                <li>Returns the smallest possible arrangement if no greater permutation exists</li>
            </ul>
        </div>
    </div>
</body>
</html> 