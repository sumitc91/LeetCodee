<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Different Ways to Add Parentheses - LeetCodee Solution</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body class="bg-gray-100">
    <header class="bg-gray-800 text-white p-4">
        <div class="container mx-auto">
            <a href="/" class="text-xl font-bold">LeetCodee</a>
        </div>
    </header>

    <main class="container mx-auto p-4">
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h1 class="text-3xl font-bold mb-4">241. Different Ways to Add Parentheses</h1>

            <div class="solution-nav mb-6">
                Jump to Solution:
                <a href="#python" class="ml-2 text-blue-600 hover:text-blue-800">Python</a>
                <a href="#java" class="ml-2 text-blue-600 hover:text-blue-800">Java</a>
                <a href="#cpp" class="ml-2 text-blue-600 hover:text-blue-800">C++</a>
                <a href="#javascript" class="ml-2 text-blue-600 hover:text-blue-800">JavaScript</a>
                <a href="#csharp" class="ml-2 text-blue-600 hover:text-blue-800">C#</a>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Problem Description</h2>
                <p class="text-gray-700 mb-4">
                    Given a string <code class="bg-gray-100 px-1 rounded">expression</code> of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.
                </p>
                <p class="text-gray-700 mb-4">
                    The test cases are generated such that the output values will fit in a 32-bit integer and the number of different results won't exceed 10⁴.
                </p>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 1:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: expression = "2-1-1"
Output: [0,2]
Explanation:
((2-1)-1) = 0
(2-(1-1)) = 2</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 2:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: expression = "2*3-4*5"
Output: [-34,-14,-10,-10,10]
Explanation:
(2*(3-(4*5))) = -34
((2*3)-(4*5)) = -14
((2*(3-4))*5) = -10
(2*((3-4)*5)) = -10
(((2*3)-4)*5) = 10</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Constraints:</h2>
                <ul class="list-disc list-inside text-gray-700">
                    <li><code class="bg-gray-100 px-1 rounded">1 <= expression.length <= 20</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">expression</code> consists of digits and the operator <code class="bg-gray-100 px-1 rounded">'+'</code>, <code class="bg-gray-100 px-1 rounded">'-'</code>, and <code class="bg-gray-100 px-1 rounded">'*'</code></li>
                    <li>All the integer values in the input expression are in the range <code class="bg-gray-100 px-1 rounded">[0, 99]</code></li>
                </ul>
            </div>
        </div>

        <!-- Solution Section -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4">Solution</h2>
            
            <!-- Python Solution -->
            <div id="python" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Python Solution</h3>
                <pre class="language-python"><code>class Solution:
    def diffWaysToCompute(self, expression: str) -> List[int]:
        # If expression is a number, return it
        if expression.isdigit():
            return [int(expression)]
        
        results = []
        for i in range(len(expression)):
            if expression[i] in "+-*":
                # Split expression at operator
                left = self.diffWaysToCompute(expression[:i])
                right = self.diffWaysToCompute(expression[i+1:])
                
                # Combine results from left and right
                for l in left:
                    for r in right:
                        if expression[i] == '+':
                            results.append(l + r)
                        elif expression[i] == '-':
                            results.append(l - r)
                        else:  # '*'
                            results.append(l * r)
                            
        return results</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(2^n)</h4>
                    <p class="text-gray-700">The number of possible ways to parenthesize grows exponentially with the length of the expression.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(2^n)</h4>
                    <p class="text-gray-700">To store all possible results.</p>
                </div>
            </div>

            <!-- Java Solution -->
            <div id="java" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Java Solution</h3>
                <pre class="language-java"><code>class Solution {
    public List<Integer> diffWaysToCompute(String expression) {
        List<Integer> results = new ArrayList<>();
        
        // If expression is a number, return it
        boolean isNumber = true;
        for (char c : expression.toCharArray()) {
            if (!Character.isDigit(c)) {
                isNumber = false;
                break;
            }
        }
        if (isNumber) {
            results.add(Integer.parseInt(expression));
            return results;
        }
        
        for (int i = 0; i < expression.length(); i++) {
            char c = expression.charAt(i);
            if (c == '+' || c == '-' || c == '*') {
                // Split expression at operator
                List<Integer> left = diffWaysToCompute(expression.substring(0, i));
                List<Integer> right = diffWaysToCompute(expression.substring(i + 1));
                
                // Combine results from left and right
                for (int l : left) {
                    for (int r : right) {
                        if (c == '+') {
                            results.add(l + r);
                        } else if (c == '-') {
                            results.add(l - r);
                        } else {  // '*'
                            results.add(l * r);
                        }
                    }
                }
            }
        }
        
        return results;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(2^n)</h4>
                    <p class="text-gray-700">The number of possible ways to parenthesize grows exponentially with the length of the expression.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(2^n)</h4>
                    <p class="text-gray-700">To store all possible results.</p>
                </div>
            </div>

            <!-- C++ Solution -->
            <div id="cpp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C++ Solution</h3>
                <pre class="language-cpp"><code>class Solution {
public:
    vector<int> diffWaysToCompute(string expression) {
        vector<int> results;
        
        // If expression is a number, return it
        bool isNumber = true;
        for (char c : expression) {
            if (!isdigit(c)) {
                isNumber = false;
                break;
            }
        }
        if (isNumber) {
            results.push_back(stoi(expression));
            return results;
        }
        
        for (int i = 0; i < expression.length(); i++) {
            char c = expression[i];
            if (c == '+' || c == '-' || c == '*') {
                // Split expression at operator
                vector<int> left = diffWaysToCompute(expression.substr(0, i));
                vector<int> right = diffWaysToCompute(expression.substr(i + 1));
                
                // Combine results from left and right
                for (int l : left) {
                    for (int r : right) {
                        if (c == '+') {
                            results.push_back(l + r);
                        } else if (c == '-') {
                            results.push_back(l - r);
                        } else {  // '*'
                            results.push_back(l * r);
                        }
                    }
                }
            }
        }
        
        return results;
    }
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(2^n)</h4>
                    <p class="text-gray-700">The number of possible ways to parenthesize grows exponentially with the length of the expression.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(2^n)</h4>
                    <p class="text-gray-700">To store all possible results.</p>
                </div>
            </div>

            <!-- JavaScript Solution -->
            <div id="javascript" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">JavaScript Solution</h3>
                <pre class="language-javascript"><code>/**
 * @param {string} expression
 * @return {number[]}
 */
var diffWaysToCompute = function(expression) {
    // If expression is a number, return it
    if (!isNaN(expression)) {
        return [parseInt(expression)];
    }
    
    const results = [];
    
    for (let i = 0; i < expression.length; i++) {
        const char = expression[i];
        if (char === '+' || char === '-' || char === '*') {
            // Split expression at operator
            const left = diffWaysToCompute(expression.slice(0, i));
            const right = diffWaysToCompute(expression.slice(i + 1));
            
            // Combine results from left and right
            for (const l of left) {
                for (const r of right) {
                    if (char === '+') {
                        results.push(l + r);
                    } else if (char === '-') {
                        results.push(l - r);
                    } else {  // '*'
                        results.push(l * r);
                    }
                }
            }
        }
    }
    
    return results;
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(2^n)</h4>
                    <p class="text-gray-700">The number of possible ways to parenthesize grows exponentially with the length of the expression.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(2^n)</h4>
                    <p class="text-gray-700">To store all possible results.</p>
                </div>
            </div>

            <!-- C# Solution -->
            <div id="csharp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C# Solution</h3>
                <pre class="language-csharp"><code>public class Solution {
    public IList<int> DiffWaysToCompute(string expression) {
        var results = new List<int>();
        
        // If expression is a number, return it
        bool isNumber = true;
        foreach (char c in expression) {
            if (!char.IsDigit(c)) {
                isNumber = false;
                break;
            }
        }
        if (isNumber) {
            results.Add(int.Parse(expression));
            return results;
        }
        
        for (int i = 0; i < expression.Length; i++) {
            char c = expression[i];
            if (c == '+' || c == '-' || c == '*') {
                // Split expression at operator
                var left = DiffWaysToCompute(expression.Substring(0, i));
                var right = DiffWaysToCompute(expression.Substring(i + 1));
                
                // Combine results from left and right
                foreach (int l in left) {
                    foreach (int r in right) {
                        if (c == '+') {
                            results.Add(l + r);
                        } else if (c == '-') {
                            results.Add(l - r);
                        } else {  // '*'
                            results.Add(l * r);
                        }
                    }
                }
            }
        }
        
        return results;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(2^n)</h4>
                    <p class="text-gray-700">The number of possible ways to parenthesize grows exponentially with the length of the expression.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(2^n)</h4>
                    <p class="text-gray-700">To store all possible results.</p>
                </div>
            </div>
        </div>

        <!-- Approach Explanation -->
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h2 class="text-2xl font-bold mb-4">Approach Explanation</h2>
            
            <div class="space-y-4">
                <p class="text-gray-700">
                    The solution uses a divide-and-conquer approach with recursion:
                </p>
                
                <ol class="list-decimal list-inside text-gray-700 ml-4">
                    <li>Key Insight:
                        <ul class="list-disc list-inside ml-8">
                            <li>Each operator can be the last operation performed</li>
                            <li>This creates a natural way to split the problem</li>
                            <li>Base case is when expression is just a number</li>
                        </ul>
                    </li>
                    <li>Algorithm Steps:
                        <ul class="list-disc list-inside ml-8">
                            <li>If expression is a number, return it as single result</li>
                            <li>For each operator in expression:
                                <ul class="list-disc list-inside ml-8">
                                    <li>Split expression into left and right parts</li>
                                    <li>Recursively compute results for both parts</li>
                                    <li>Combine results using the operator</li>
                                </ul>
                            </li>
                            <li>Return all possible results</li>
                        </ul>
                    </li>
                </ol>

                <p class="text-gray-700 mt-4">
                    Example walkthrough for "2-1-1":
                    <ul class="list-disc list-inside ml-4">
                        <li>First split at first '-': "2" and "1-1"
                            <ul class="list-disc list-inside ml-8">
                                <li>Left: "2" → [2]</li>
                                <li>Right: "1-1" → [0]</li>
                                <li>Result: 2-0 = 2</li>
                            </ul>
                        </li>
                        <li>Then split at second '-': "2-1" and "1"
                            <ul class="list-disc list-inside ml-8">
                                <li>Left: "2-1" → [1]</li>
                                <li>Right: "1" → [1]</li>
                                <li>Result: 1-1 = 0</li>
                            </ul>
                        </li>
                    </ul>
                </p>

                <p class="text-gray-700 mt-4">
                    Key insights:
                    <ul class="list-disc list-inside ml-4">
                        <li>Natural recursive solution</li>
                        <li>Handles all operator precedences</li>
                        <li>Results may contain duplicates</li>
                        <li>Order of results doesn't matter</li>
                    </ul>
                </p>
            </div>
        </div>
    </main>

    <footer class="bg-gray-800 text-white p-4 mt-8">
        <div class="container mx-auto text-center">
            <p>© 2024 LeetCodee. All rights reserved.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html> 