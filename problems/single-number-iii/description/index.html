<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Single Number III - LeetCodee Solution</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body class="bg-gray-100">
    <header class="bg-gray-800 text-white p-4">
        <div class="container mx-auto">
            <a href="/" class="text-xl font-bold">LeetCodee</a>
        </div>
    </header>

    <main class="container mx-auto p-4">
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h1 class="text-3xl font-bold mb-4">260. Single Number III</h1>

            <div class="solution-nav mb-6">
                Jump to Solution:
                <a href="#python" class="ml-2 text-blue-600 hover:text-blue-800">Python</a>
                <a href="#java" class="ml-2 text-blue-600 hover:text-blue-800">Java</a>
                <a href="#cpp" class="ml-2 text-blue-600 hover:text-blue-800">C++</a>
                <a href="#javascript" class="ml-2 text-blue-600 hover:text-blue-800">JavaScript</a>
                <a href="#csharp" class="ml-2 text-blue-600 hover:text-blue-800">C#</a>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Problem Description</h2>
                <p class="text-gray-700 mb-4">
                    Given an integer array <code class="bg-gray-100 px-1 rounded">nums</code>, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.
                </p>
                <p class="text-gray-700 mb-4">
                    You must write an algorithm that runs in linear runtime complexity and uses only constant extra space.
                </p>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 1:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: nums = [1,2,1,3,2,5]
Output: [3,5]
Explanation: [5,3] is also a valid answer.</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 2:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: nums = [-1,0]
Output: [-1,0]</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 3:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: nums = [0,1]
Output: [1,0]</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Constraints:</h2>
                <ul class="list-disc list-inside text-gray-700">
                    <li><code class="bg-gray-100 px-1 rounded">2 <= nums.length <= 3 * 10⁴</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">-2³¹ <= nums[i] <= 2³¹ - 1</code></li>
                    <li>Each integer in <code class="bg-gray-100 px-1 rounded">nums</code> will appear twice, only two integers will appear once.</li>
                </ul>
            </div>
        </div>

        <!-- Solution Section -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4">Solution</h2>
            
            <!-- Python Solution -->
            <div id="python" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Python Solution</h3>
                <pre class="language-python"><code>class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        # Get XOR of all numbers
        xor = 0
        for num in nums:
            xor ^= num
            
        # Find rightmost set bit in xor
        rightmost_set_bit = xor & -xor
        
        # Divide numbers into two groups based on rightmost set bit
        x = y = 0
        for num in nums:
            if num & rightmost_set_bit:
                x ^= num
            else:
                y ^= num
                
        return [x, y]</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(n)</h4>
                    <p class="text-gray-700">We need to traverse the array twice.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(1)</h4>
                    <p class="text-gray-700">Only uses a constant amount of extra space.</p>
                </div>
            </div>

            <!-- Java Solution -->
            <div id="java" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Java Solution</h3>
                <pre class="language-java"><code>class Solution {
    public int[] singleNumber(int[] nums) {
        // Get XOR of all numbers
        int xor = 0;
        for (int num : nums) {
            xor ^= num;
        }
        
        // Find rightmost set bit in xor
        int rightmostSetBit = xor & -xor;
        
        // Divide numbers into two groups based on rightmost set bit
        int x = 0, y = 0;
        for (int num : nums) {
            if ((num & rightmostSetBit) != 0) {
                x ^= num;
            } else {
                y ^= num;
            }
        }
        
        return new int[]{x, y};
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(n)</h4>
                    <p class="text-gray-700">We need to traverse the array twice.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(1)</h4>
                    <p class="text-gray-700">Only uses a constant amount of extra space.</p>
                </div>
            </div>

            <!-- C++ Solution -->
            <div id="cpp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C++ Solution</h3>
                <pre class="language-cpp"><code>class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        // Get XOR of all numbers
        int xor_result = 0;
        for (int num : nums) {
            xor_result ^= num;
        }
        
        // Find rightmost set bit in xor
        int rightmost_set_bit = xor_result & -xor_result;
        
        // Divide numbers into two groups based on rightmost set bit
        int x = 0, y = 0;
        for (int num : nums) {
            if (num & rightmost_set_bit) {
                x ^= num;
            } else {
                y ^= num;
            }
        }
        
        return {x, y};
    }
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(n)</h4>
                    <p class="text-gray-700">We need to traverse the array twice.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(1)</h4>
                    <p class="text-gray-700">Only uses a constant amount of extra space.</p>
                </div>
            </div>

            <!-- JavaScript Solution -->
            <div id="javascript" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">JavaScript Solution</h3>
                <pre class="language-javascript"><code>/**
 * @param {number[]} nums
 * @return {number[]}
 */
var singleNumber = function(nums) {
    // Get XOR of all numbers
    let xor = 0;
    for (const num of nums) {
        xor ^= num;
    }
    
    // Find rightmost set bit in xor
    const rightmostSetBit = xor & -xor;
    
    // Divide numbers into two groups based on rightmost set bit
    let x = 0, y = 0;
    for (const num of nums) {
        if (num & rightmostSetBit) {
            x ^= num;
        } else {
            y ^= num;
        }
    }
    
    return [x, y];
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(n)</h4>
                    <p class="text-gray-700">We need to traverse the array twice.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(1)</h4>
                    <p class="text-gray-700">Only uses a constant amount of extra space.</p>
                </div>
            </div>

            <!-- C# Solution -->
            <div id="csharp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C# Solution</h3>
                <pre class="language-csharp"><code>public class Solution {
    public int[] SingleNumber(int[] nums) {
        // Get XOR of all numbers
        int xor = 0;
        foreach (int num in nums) {
            xor ^= num;
        }
        
        // Find rightmost set bit in xor
        int rightmostSetBit = xor & -xor;
        
        // Divide numbers into two groups based on rightmost set bit
        int x = 0, y = 0;
        foreach (int num in nums) {
            if ((num & rightmostSetBit) != 0) {
                x ^= num;
            } else {
                y ^= num;
            }
        }
        
        return new int[]{x, y};
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(n)</h4>
                    <p class="text-gray-700">We need to traverse the array twice.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(1)</h4>
                    <p class="text-gray-700">Only uses a constant amount of extra space.</p>
                </div>
            </div>
        </div>

        <!-- Approach Explanation -->
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h2 class="text-2xl font-bold mb-4">Approach Explanation</h2>
            
            <div class="space-y-4">
                <p class="text-gray-700">
                    The solution uses bit manipulation to find the two unique numbers:
                </p>
                
                <ol class="list-decimal list-inside text-gray-700 ml-4">
                    <li>Key Insight:
                        <ul class="list-disc list-inside ml-8">
                            <li>XOR of all numbers gives XOR of two unique numbers</li>
                            <li>Find a bit where these numbers differ</li>
                            <li>Use this bit to separate numbers into two groups</li>
                        </ul>
                    </li>
                    <li>Algorithm Steps:
                        <ul class="list-disc list-inside ml-8">
                            <li>Get XOR of all numbers</li>
                            <li>Find rightmost set bit in XOR result</li>
                            <li>Divide numbers into two groups based on this bit</li>
                            <li>XOR numbers in each group separately</li>
                        </ul>
                    </li>
                </ol>

                <p class="text-gray-700 mt-4">
                    Example walkthrough for [1,2,1,3,2,5]:
                    <ul class="list-disc list-inside ml-4">
                        <li>XOR of all numbers: 1⊕2⊕1⊕3⊕2⊕5 = 3⊕5 = 6</li>
                        <li>Binary: 6 = 110₂</li>
                        <li>Rightmost set bit: 2 = 010₂</li>
                        <li>Group 1 (bit set): [2,2,3] → 3</li>
                        <li>Group 2 (bit not set): [1,1,5] → 5</li>
                    </ul>
                </p>

                <p class="text-gray-700 mt-4">
                    Key insights:
                    <ul class="list-disc list-inside ml-4">
                        <li>XOR properties for finding unique elements</li>
                        <li>Efficient bit manipulation techniques</li>
                        <li>Linear time complexity</li>
                        <li>Constant space complexity</li>
                    </ul>
                </p>

                <p class="text-gray-700 mt-4">
                    Bit Manipulation Details:
                    <ul class="list-disc list-inside ml-4">
                        <li>x & -x isolates rightmost set bit</li>
                        <li>XOR cancels out pairs of numbers</li>
                        <li>Different bits indicate different numbers</li>
                        <li>Works with both positive and negative numbers</li>
                    </ul>
                </p>
            </div>
        </div>
    </main>

    <footer class="bg-gray-800 text-white p-4 mt-8">
        <div class="container mx-auto text-center">
            <p>© 2024 LeetCodee. All rights reserved.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html> 