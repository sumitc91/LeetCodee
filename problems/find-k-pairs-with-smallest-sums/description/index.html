<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Find K Pairs with Smallest Sums - LeetCodee Solution</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body class="bg-gray-100">
    <header class="bg-gray-800 text-white p-4">
        <div class="container mx-auto">
            <a href="/" class="text-xl font-bold">LeetCodee</a>
        </div>
    </header>

    <main class="container mx-auto p-4">
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h1 class="text-3xl font-bold mb-4">373. Find K Pairs with Smallest Sums</h1>

            <div class="solution-nav mb-6">
                Jump to Solution:
                <a href="#python" class="ml-2 text-blue-600 hover:text-blue-800">Python</a>
                <a href="#java" class="ml-2 text-blue-600 hover:text-blue-800">Java</a>
                <a href="#cpp" class="ml-2 text-blue-600 hover:text-blue-800">C++</a>
                <a href="#javascript" class="ml-2 text-blue-600 hover:text-blue-800">JavaScript</a>
                <a href="#csharp" class="ml-2 text-blue-600 hover:text-blue-800">C#</a>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Problem Description</h2>
                <p class="text-gray-700 mb-4">
                    You are given two integer arrays <code class="bg-gray-100 px-1 rounded">nums1</code> and <code class="bg-gray-100 px-1 rounded">nums2</code> sorted in ascending order and an integer <code class="bg-gray-100 px-1 rounded">k</code>. Define a pair <code class="bg-gray-100 px-1 rounded">(u, v)</code> which consists of one element from the first array and one element from the second array. Return the <code class="bg-gray-100 px-1 rounded">k</code> pairs <code class="bg-gray-100 px-1 rounded">(u₁, v₁), (u₂, v₂), ..., (uₖ, vₖ)</code> with the smallest sums.
                </p>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 1:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: nums1 = [1,7,11], nums2 = [2,4,6], k = 3
Output: [[1,2],[1,4],[1,6]]
Explanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 2:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: nums1 = [1,1,2], nums2 = [1,2,3], k = 2
Output: [[1,1],[1,1]]
Explanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 3:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: nums1 = [1,2], nums2 = [3], k = 3
Output: [[1,3],[2,3]]
Explanation: All possible pairs are returned from the sequence: [1,3],[2,3]</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Constraints:</h2>
                <ul class="list-disc list-inside text-gray-700">
                    <li><code class="bg-gray-100 px-1 rounded">1 <= nums1.length, nums2.length <= 10⁵</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">-10⁹ <= nums1[i], nums2[i] <= 10⁹</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">nums1</code> and <code class="bg-gray-100 px-1 rounded">nums2</code> both are sorted in ascending order</li>
                    <li><code class="bg-gray-100 px-1 rounded">1 <= k <= 10⁴</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">k <= nums1.length * nums2.length</code></li>
                </ul>
            </div>
        </div>

        <!-- Solution Section -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4">Solution</h2>
            
            <!-- Python Solution -->
            <div id="python" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Python Solution</h3>
                <pre class="language-python"><code>class Solution:
    def kSmallestPairs(self, nums1: List[int], nums2: List[int], k: int) -> List[List[int]]:
        if not nums1 or not nums2:
            return []
        
        # Priority queue to store pairs with smallest sums
        # Each element is (sum, i, j) where i, j are indices in nums1 and nums2
        heap = [(nums1[0] + nums2[0], 0, 0)]
        result = []
        seen = {(0, 0)}  # Keep track of visited pairs
        
        while heap and len(result) < k:
            curr_sum, i, j = heapq.heappop(heap)
            result.append([nums1[i], nums2[j]])
            
            # Try next element in nums2
            if j + 1 < len(nums2) and (i, j + 1) not in seen:
                heapq.heappush(heap, (nums1[i] + nums2[j + 1], i, j + 1))
                seen.add((i, j + 1))
            
            # Try next element in nums1
            if i + 1 < len(nums1) and (i + 1, j) not in seen:
                heapq.heappush(heap, (nums1[i + 1] + nums2[j], i + 1, j))
                seen.add((i + 1, j))
        
        return result</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(k log k)</h4>
                    <p class="text-gray-700">Where k is the number of pairs we need to find. Each heap operation takes O(log k) time.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(k)</h4>
                    <p class="text-gray-700">For storing the heap and seen set.</p>
                </div>
            </div>

            <!-- Java Solution -->
            <div id="java" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Java Solution</h3>
                <pre class="language-java"><code>class Solution {
    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {
        List<List<Integer>> result = new ArrayList<>();
        if (nums1.length == 0 || nums2.length == 0) {
            return result;
        }
        
        // Priority queue to store pairs with smallest sums
        // Each element is [sum, i, j] where i, j are indices in nums1 and nums2
        PriorityQueue<int[]> heap = new PriorityQueue<>((a, b) -> a[0] - b[0]);
        Set<String> seen = new HashSet<>();
        
        // Add first pair
        heap.offer(new int[]{nums1[0] + nums2[0], 0, 0});
        seen.add("0,0");
        
        while (!heap.isEmpty() && result.size() < k) {
            int[] curr = heap.poll();
            int i = curr[1], j = curr[2];
            
            result.add(Arrays.asList(nums1[i], nums2[j]));
            
            // Try next element in nums2
            if (j + 1 < nums2.length && !seen.contains(i + "," + (j + 1))) {
                heap.offer(new int[]{nums1[i] + nums2[j + 1], i, j + 1});
                seen.add(i + "," + (j + 1));
            }
            
            // Try next element in nums1
            if (i + 1 < nums1.length && !seen.contains((i + 1) + "," + j)) {
                heap.offer(new int[]{nums1[i + 1] + nums2[j], i + 1, j});
                seen.add((i + 1) + "," + j);
            }
        }
        
        return result;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(k log k)</h4>
                    <p class="text-gray-700">Where k is the number of pairs we need to find. Each heap operation takes O(log k) time.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(k)</h4>
                    <p class="text-gray-700">For storing the heap and seen set.</p>
                </div>
            </div>

            <!-- C++ Solution -->
            <div id="cpp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C++ Solution</h3>
                <pre class="language-cpp"><code>class Solution {
public:
    vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {
        vector<vector<int>> result;
        if (nums1.empty() || nums2.empty()) {
            return result;
        }
        
        // Priority queue to store pairs with smallest sums
        // Each element is {sum, {i, j}} where i, j are indices in nums1 and nums2
        priority_queue<pair<int, pair<int, int>>, 
                      vector<pair<int, pair<int, int>>>, 
                      greater<>> heap;
        set<pair<int, int>> seen;
        
        // Add first pair
        heap.push({nums1[0] + nums2[0], {0, 0}});
        seen.insert({0, 0});
        
        while (!heap.empty() && result.size() < k) {
            auto [sum, indices] = heap.top();
            auto [i, j] = indices;
            heap.pop();
            
            result.push_back({nums1[i], nums2[j]});
            
            // Try next element in nums2
            if (j + 1 < nums2.size() && seen.find({i, j + 1}) == seen.end()) {
                heap.push({nums1[i] + nums2[j + 1], {i, j + 1}});
                seen.insert({i, j + 1});
            }
            
            // Try next element in nums1
            if (i + 1 < nums1.size() && seen.find({i + 1, j}) == seen.end()) {
                heap.push({nums1[i + 1] + nums2[j], {i + 1, j}});
                seen.insert({i + 1, j});
            }
        }
        
        return result;
    }
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(k log k)</h4>
                    <p class="text-gray-700">Where k is the number of pairs we need to find. Each heap operation takes O(log k) time.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(k)</h4>
                    <p class="text-gray-700">For storing the heap and seen set.</p>
                </div>
            </div>

            <!-- JavaScript Solution -->
            <div id="javascript" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">JavaScript Solution</h3>
                <pre class="language-javascript"><code>/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number} k
 * @return {number[][]}
 */
var kSmallestPairs = function(nums1, nums2, k) {
    if (!nums1.length || !nums2.length) {
        return [];
    }
    
    // MinHeap implementation
    class MinHeap {
        constructor() {
            this.heap = [];
        }
        
        push(val) {
            this.heap.push(val);
            this.bubbleUp(this.heap.length - 1);
        }
        
        pop() {
            if (this.heap.length === 0) return null;
            if (this.heap.length === 1) return this.heap.pop();
            
            const result = this.heap[0];
            this.heap[0] = this.heap.pop();
            this.bubbleDown(0);
            return result;
        }
        
        bubbleUp(index) {
            while (index > 0) {
                const parentIndex = Math.floor((index - 1) / 2);
                if (this.heap[parentIndex][0] <= this.heap[index][0]) break;
                
                [this.heap[parentIndex], this.heap[index]] = 
                    [this.heap[index], this.heap[parentIndex]];
                index = parentIndex;
            }
        }
        
        bubbleDown(index) {
            while (true) {
                let smallest = index;
                const leftChild = 2 * index + 1;
                const rightChild = 2 * index + 2;
                
                if (leftChild < this.heap.length && 
                    this.heap[leftChild][0] < this.heap[smallest][0]) {
                    smallest = leftChild;
                }
                if (rightChild < this.heap.length && 
                    this.heap[rightChild][0] < this.heap[smallest][0]) {
                    smallest = rightChild;
                }
                
                if (smallest === index) break;
                
                [this.heap[index], this.heap[smallest]] = 
                    [this.heap[smallest], this.heap[index]];
                index = smallest;
            }
        }
        
        isEmpty() {
            return this.heap.length === 0;
        }
    }
    
    const result = [];
    const heap = new MinHeap();
    const seen = new Set();
    
    // Add first pair
    heap.push([nums1[0] + nums2[0], 0, 0]);
    seen.add('0,0');
    
    while (!heap.isEmpty() && result.length < k) {
        const [sum, i, j] = heap.pop();
        result.push([nums1[i], nums2[j]]);
        
        // Try next element in nums2
        if (j + 1 < nums2.length && !seen.has(`${i},${j+1}`)) {
            heap.push([nums1[i] + nums2[j + 1], i, j + 1]);
            seen.add(`${i},${j+1}`);
        }
        
        // Try next element in nums1
        if (i + 1 < nums1.length && !seen.has(`${i+1},${j}`)) {
            heap.push([nums1[i + 1] + nums2[j], i + 1, j]);
            seen.add(`${i+1},${j}`);
        }
    }
    
    return result;
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(k log k)</h4>
                    <p class="text-gray-700">Where k is the number of pairs we need to find. Each heap operation takes O(log k) time.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(k)</h4>
                    <p class="text-gray-700">For storing the heap and seen set.</p>
                </div>
            </div>

            <!-- C# Solution -->
            <div id="csharp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C# Solution</h3>
                <pre class="language-csharp"><code>public class Solution {
    public IList<IList<int>> KSmallestPairs(int[] nums1, int[] nums2, int k) {
        var result = new List<IList<int>>();
        if (nums1.Length == 0 || nums2.Length == 0) {
            return result;
        }
        
        // Priority queue to store pairs with smallest sums
        // Each element is (sum, i, j) where i, j are indices in nums1 and nums2
        var heap = new PriorityQueue<(int i, int j), int>();
        var seen = new HashSet<string>();
        
        // Add first pair
        heap.Enqueue((0, 0), nums1[0] + nums2[0]);
        seen.Add("0,0");
        
        while (heap.Count > 0 && result.Count < k) {
            var (i, j) = heap.Dequeue();
            result.Add(new List<int> { nums1[i], nums2[j] });
            
            // Try next element in nums2
            if (j + 1 < nums2.Length && !seen.Contains($"{i},{j+1}")) {
                heap.Enqueue((i, j + 1), nums1[i] + nums2[j + 1]);
                seen.Add($"{i},{j+1}");
            }
            
            // Try next element in nums1
            if (i + 1 < nums1.Length && !seen.Contains($"{i+1},{j}")) {
                heap.Enqueue((i + 1, j), nums1[i + 1] + nums2[j]);
                seen.Add($"{i+1},{j}");
            }
        }
        
        return result;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(k log k)</h4>
                    <p class="text-gray-700">Where k is the number of pairs we need to find. Each heap operation takes O(log k) time.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(k)</h4>
                    <p class="text-gray-700">For storing the heap and seen set.</p>
                </div>
            </div>
        </div>

        <!-- Approach Explanation -->
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h2 class="text-2xl font-bold mb-4">Approach Explanation</h2>
            
            <div class="space-y-4">
                <p class="text-gray-700">
                    The solution uses a min-heap approach to efficiently find the k pairs with smallest sums:
                </p>
                
                <ol class="list-decimal list-inside text-gray-700 ml-4">
                    <li>Key Insights:
                        <ul class="list-disc list-inside ml-8">
                            <li>Arrays are sorted in ascending order</li>
                            <li>Use min-heap to track smallest sums</li>
                            <li>Track visited pairs to avoid duplicates</li>
                            <li>Process pairs incrementally</li>
                        </ul>
                    </li>
                    <li>Algorithm Steps:
                        <ul class="list-disc list-inside ml-8">
                            <li>Initialize min-heap with first pair</li>
                            <li>Process pairs until k pairs found</li>
                            <li>Add next possible pairs to heap</li>
                            <li>Track visited pairs using set</li>
                        </ul>
                    </li>
                </ol>

                <p class="text-gray-700 mt-4">
                    Implementation Details:
                    <ul class="list-disc list-inside ml-4">
                        <li>Use priority queue/min-heap</li>
                        <li>Track indices and sums</li>
                        <li>Handle empty arrays</li>
                        <li>Process pairs efficiently</li>
                    </ul>
                </p>

                <p class="text-gray-700 mt-4">
                    Optimization Insights:
                    <ul class="list-disc list-inside ml-4">
                        <li>Early termination when k pairs found</li>
                        <li>Avoid duplicate pairs</li>
                        <li>Efficient heap operations</li>
                        <li>Memory-efficient tracking</li>
                    </ul>
                </p>

                <p class="text-gray-700 mt-4">
                    Edge Cases:
                    <ul class="list-disc list-inside ml-4">
                        <li>Empty arrays</li>
                        <li>k larger than possible pairs</li>
                        <li>Single element arrays</li>
                        <li>Duplicate elements</li>
                    </ul>
                </p>
            </div>
        </div>
    </main>

    <footer class="bg-gray-800 text-white p-4 mt-8">
        <div class="container mx-auto text-center">
            <p>© 2024 LeetCodee. All rights reserved.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html> 