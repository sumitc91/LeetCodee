<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Random Flip Matrix - LeetCodee Solution</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body class="bg-gray-100">
    <header class="bg-gray-800 text-white p-4">
        <div class="container mx-auto">
            <a href="/" class="text-xl font-bold">LeetCodee</a>
        </div>
    </header>

    <main class="container mx-auto p-4">
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h1 class="text-3xl font-bold mb-4">519. Random Flip Matrix</h1>

            <div class="solution-nav mb-6">
                Jump to Solution:
                <a href="#python" class="ml-2 text-blue-600 hover:text-blue-800">Python</a>
                <a href="#java" class="ml-2 text-blue-600 hover:text-blue-800">Java</a>
                <a href="#cpp" class="ml-2 text-blue-600 hover:text-blue-800">C++</a>
                <a href="#javascript" class="ml-2 text-blue-600 hover:text-blue-800">JavaScript</a>
                <a href="#csharp" class="ml-2 text-blue-600 hover:text-blue-800">C#</a>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Problem Description</h2>
                <p class="text-gray-700 mb-4">
                    There is an <code class="bg-gray-100 px-1 rounded">m x n</code> binary grid matrix with all the values set to 0 initially. Design an algorithm to randomly pick an index <code class="bg-gray-100 px-1 rounded">(i, j)</code> where <code class="bg-gray-100 px-1 rounded">matrix[i][j] == 0</code> and flips it to 1. All the indices <code class="bg-gray-100 px-1 rounded">(i, j)</code> where <code class="bg-gray-100 px-1 rounded">matrix[i][j] == 0</code> should be equally likely to be returned.
                </p>
                <p class="text-gray-700 mb-4">
                    Optimize your algorithm to minimize the number of calls to the built-in random function of your language and optimize the time and space complexity.
                </p>
                <p class="text-gray-700 mb-4">
                    Implement the <code class="bg-gray-100 px-1 rounded">Solution</code> class:
                </p>
                <ul class="list-disc list-inside text-gray-700 mb-4">
                    <li><code class="bg-gray-100 px-1 rounded">Solution(int m, int n)</code> Initializes the object with the number of rows <code class="bg-gray-100 px-1 rounded">m</code> and the number of columns <code class="bg-gray-100 px-1 rounded">n</code> of the binary matrix.</li>
                    <li><code class="bg-gray-100 px-1 rounded">int[] flip()</code> Returns a random index <code class="bg-gray-100 px-1 rounded">[i, j]</code> of the matrix where <code class="bg-gray-100 px-1 rounded">matrix[i][j] == 0</code> and flips it to 1.</li>
                    <li><code class="bg-gray-100 px-1 rounded">void reset()</code> Resets all the values of the matrix to 0.</li>
                </ul>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 1:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input
["Solution", "flip", "flip", "flip", "reset", "flip"]
[[3, 1], [], [], [], [], []]
Output
[null, [1, 0], [2, 0], [0, 0], null, [2, 0]]

Explanation
Solution solution = new Solution(3, 1);
solution.flip();  // returns [1, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.
solution.flip();  // returns [2, 0], [0,0] and [2,0] should be equally likely to be returned.
solution.flip();  // returns [0, 0], [0,0] should be returned
solution.reset(); // All the values are reset to 0 and can be returned.
solution.flip();  // returns [2, 0], [0,0], [1,0], and [2,0] should be equally likely to be returned.</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Constraints:</h2>
                <ul class="list-disc list-inside text-gray-700">
                    <li><code class="bg-gray-100 px-1 rounded">1 <= m, n <= 10⁴</code></li>
                    <li>There will be at least one free cell for each call to <code class="bg-gray-100 px-1 rounded">flip</code>.</li>
                    <li>At most <code class="bg-gray-100 px-1 rounded">1000</code> calls will be made to <code class="bg-gray-100 px-1 rounded">flip</code> and <code class="bg-gray-100 px-1 rounded">reset</code>.</li>
                </ul>
            </div>
        </div>

        <!-- Solution Section -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4">Solution</h2>
            
            <!-- Python Solution -->
            <div id="python" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Python Solution</h3>
                <pre class="language-python"><code>class Solution:
    def __init__(self, m: int, n: int):
        self.m = m
        self.n = n
        self.total = m * n
        self.used = {}
        
    def flip(self) -> List[int]:
        # Generate a random index from remaining indices
        rand_idx = random.randrange(self.total)
        self.total -= 1
        
        # Get actual index using mapping or rand_idx if not mapped
        actual_idx = self.used.get(rand_idx, rand_idx)
        # Map rand_idx to last available index if not already mapped
        self.used[rand_idx] = self.used.get(self.total, self.total)
        
        # Convert to 2D coordinates
        return [actual_idx // self.n, actual_idx % self.n]
        
    def reset(self) -> None:
        self.total = self.m * self.n
        self.used.clear()</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity:</h4>
                    <ul class="list-disc list-inside text-gray-700">
                        <li>Constructor: O(1)</li>
                        <li>flip(): O(1)</li>
                        <li>reset(): O(1)</li>
                    </ul>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(min(k, m*n))</h4>
                    <p class="text-gray-700">Where k is the number of calls to flip(). We only store used indices.</p>
                </div>
            </div>

            <!-- Java Solution -->
            <div id="java" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Java Solution</h3>
                <pre class="language-java"><code>class Solution {
    private int m, n, total;
    private Map<Integer, Integer> used;
    private Random rand;
    
    public Solution(int m, int n) {
        this.m = m;
        this.n = n;
        this.total = m * n;
        this.used = new HashMap<>();
        this.rand = new Random();
    }
    
    public int[] flip() {
        // Generate a random index from remaining indices
        int randIdx = rand.nextInt(total);
        total--;
        
        // Get actual index using mapping or randIdx if not mapped
        int actualIdx = used.getOrDefault(randIdx, randIdx);
        // Map randIdx to last available index if not already mapped
        used.put(randIdx, used.getOrDefault(total, total));
        
        // Convert to 2D coordinates
        return new int[]{actualIdx / n, actualIdx % n};
    }
    
    public void reset() {
        total = m * n;
        used.clear();
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity:</h4>
                    <ul class="list-disc list-inside text-gray-700">
                        <li>Constructor: O(1)</li>
                        <li>flip(): O(1)</li>
                        <li>reset(): O(1)</li>
                    </ul>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(min(k, m*n))</h4>
                    <p class="text-gray-700">Where k is the number of calls to flip(). We only store used indices.</p>
                </div>
            </div>

            <!-- C++ Solution -->
            <div id="cpp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C++ Solution</h3>
                <pre class="language-cpp"><code>class Solution {
private:
    int m, n, total;
    unordered_map<int, int> used;
    
public:
    Solution(int m, int n) {
        this->m = m;
        this->n = n;
        this->total = m * n;
    }
    
    vector<int> flip() {
        // Generate a random index from remaining indices
        int randIdx = rand() % total;
        total--;
        
        // Get actual index using mapping or randIdx if not mapped
        int actualIdx = used.count(randIdx) ? used[randIdx] : randIdx;
        // Map randIdx to last available index if not already mapped
        used[randIdx] = used.count(total) ? used[total] : total;
        
        // Convert to 2D coordinates
        return {actualIdx / n, actualIdx % n};
    }
    
    void reset() {
        total = m * n;
        used.clear();
    }
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity:</h4>
                    <ul class="list-disc list-inside text-gray-700">
                        <li>Constructor: O(1)</li>
                        <li>flip(): O(1)</li>
                        <li>reset(): O(1)</li>
                    </ul>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(min(k, m*n))</h4>
                    <p class="text-gray-700">Where k is the number of calls to flip(). We only store used indices.</p>
                </div>
            </div>

            <!-- JavaScript Solution -->
            <div id="javascript" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">JavaScript Solution</h3>
                <pre class="language-javascript"><code>/**
 * @param {number} m
 * @param {number} n
 */
class Solution {
    constructor(m, n) {
        this.m = m;
        this.n = n;
        this.total = m * n;
        this.used = new Map();
    }
    
    /** 
     * @return {number[]}
     */
    flip() {
        // Generate a random index from remaining indices
        const randIdx = Math.floor(Math.random() * this.total);
        this.total--;
        
        // Get actual index using mapping or randIdx if not mapped
        const actualIdx = this.used.has(randIdx) ? this.used.get(randIdx) : randIdx;
        // Map randIdx to last available index if not already mapped
        this.used.set(randIdx, this.used.has(this.total) ? this.used.get(this.total) : this.total);
        
        // Convert to 2D coordinates
        return [Math.floor(actualIdx / this.n), actualIdx % this.n];
    }
    
    /** 
     * @return {void}
     */
    reset() {
        this.total = this.m * this.n;
        this.used.clear();
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity:</h4>
                    <ul class="list-disc list-inside text-gray-700">
                        <li>Constructor: O(1)</li>
                        <li>flip(): O(1)</li>
                        <li>reset(): O(1)</li>
                    </ul>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(min(k, m*n))</h4>
                    <p class="text-gray-700">Where k is the number of calls to flip(). We only store used indices.</p>
                </div>
            </div>

            <!-- C# Solution -->
            <div id="csharp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C# Solution</h3>
                <pre class="language-csharp"><code>public class Solution {
    private int m, n, total;
    private Dictionary<int, int> used;
    private Random rand;
    
    public Solution(int m, int n) {
        this.m = m;
        this.n = n;
        this.total = m * n;
        this.used = new Dictionary<int, int>();
        this.rand = new Random();
    }
    
    public int[] Flip() {
        // Generate a random index from remaining indices
        int randIdx = rand.Next(total);
        total--;
        
        // Get actual index using mapping or randIdx if not mapped
        int actualIdx = used.ContainsKey(randIdx) ? used[randIdx] : randIdx;
        // Map randIdx to last available index if not already mapped
        used[randIdx] = used.ContainsKey(total) ? used[total] : total;
        
        // Convert to 2D coordinates
        return new int[]{actualIdx / n, actualIdx % n};
    }
    
    public void Reset() {
        total = m * n;
        used.Clear();
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity:</h4>
                    <ul class="list-disc list-inside text-gray-700">
                        <li>Constructor: O(1)</li>
                        <li>flip(): O(1)</li>
                        <li>reset(): O(1)</li>
                    </ul>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(min(k, m*n))</h4>
                    <p class="text-gray-700">Where k is the number of calls to flip(). We only store used indices.</p>
                </div>
            </div>
        </div>

        <!-- Approach Explanation -->
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h2 class="text-2xl font-bold mb-4">Approach Explanation</h2>
            
            <div class="space-y-4">
                <p class="text-gray-700">
                    The solution uses a virtual matrix approach with index mapping:
                </p>
                
                <ol class="list-decimal list-inside text-gray-700 ml-4">
                    <li>Key Insights:
                        <ul class="list-disc list-inside ml-8">
                            <li>Virtual matrix representation</li>
                            <li>Index mapping technique</li>
                            <li>Random selection</li>
                            <li>Efficient reset</li>
                        </ul>
                    </li>
                    <li>Algorithm Steps:
                        <ul class="list-disc list-inside ml-8">
                            <li>Initialize total cells</li>
                            <li>Generate random index</li>
                            <li>Map indices</li>
                            <li>Convert to coordinates</li>
                        </ul>
                    </li>
                </ol>

                <p class="text-gray-700 mt-4">
                    Implementation Details:
                    <ul class="list-disc list-inside ml-4">
                        <li>Random generation</li>
                        <li>Index mapping</li>
                        <li>Coordinate conversion</li>
                        <li>State management</li>
                    </ul>
                </p>

                <p class="text-gray-700 mt-4">
                    Optimization Insights:
                    <ul class="list-disc list-inside ml-4">
                        <li>Constant time operations</li>
                        <li>Space efficiency</li>
                        <li>Minimal random calls</li>
                        <li>Fast reset</li>
                    </ul>
                </p>

                <p class="text-gray-700 mt-4">
                    Edge Cases:
                    <ul class="list-disc list-inside ml-4">
                        <li>Single cell matrix</li>
                        <li>Last cell flip</li>
                        <li>Reset after all flips</li>
                        <li>Multiple resets</li>
                    </ul>
                </p>
            </div>
        </div>
    </main>

    <footer class="bg-gray-800 text-white p-4 mt-8">
        <div class="container mx-auto text-center">
            <p>© 2024 LeetCodee. All rights reserved.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html> 