<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sliding Window Maximum - LeetCodee Solution</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body class="bg-gray-100">
    <header class="bg-gray-800 text-white p-4">
        <div class="container mx-auto">
            <a href="/" class="text-xl font-bold">LeetCodee</a>
        </div>
    </header>

    <main class="container mx-auto p-4">
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h1 class="text-3xl font-bold mb-4">239. Sliding Window Maximum</h1>

            <div class="solution-nav mb-6">
                Jump to Solution:
                <a href="#python" class="ml-2 text-blue-600 hover:text-blue-800">Python</a>
                <a href="#java" class="ml-2 text-blue-600 hover:text-blue-800">Java</a>
                <a href="#cpp" class="ml-2 text-blue-600 hover:text-blue-800">C++</a>
                <a href="#javascript" class="ml-2 text-blue-600 hover:text-blue-800">JavaScript</a>
                <a href="#csharp" class="ml-2 text-blue-600 hover:text-blue-800">C#</a>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Problem Description</h2>
                <p class="text-gray-700 mb-4">
                    You are given an array of integers <code class="bg-gray-100 px-1 rounded">nums</code>, there is a sliding window of size <code class="bg-gray-100 px-1 rounded">k</code> which is moving from the very left of the array to the very right. You can only see the <code class="bg-gray-100 px-1 rounded">k</code> numbers in the window. Each time the sliding window moves right by one position.
                </p>
                <p class="text-gray-700 mb-4">
                    Return an array of the maximum element in each sliding window.
                </p>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 1:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]
Explanation: 
Window position                Max
---------------               -----
[1  3  -1] -3  5  3  6  7     3
 1 [3  -1  -3] 5  3  6  7     3
 1  3 [-1  -3  5] 3  6  7     5
 1  3  -1 [-3  5  3] 6  7     5
 1  3  -1  -3 [5  3  6] 7     6
 1  3  -1  -3  5 [3  6  7]    7</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 2:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: nums = [1], k = 1
Output: [1]</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Constraints:</h2>
                <ul class="list-disc list-inside text-gray-700">
                    <li><code class="bg-gray-100 px-1 rounded">1 <= nums.length <= 10⁵</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">-10⁴ <= nums[i] <= 10⁴</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">1 <= k <= nums.length</code></li>
                </ul>
            </div>
        </div>

        <!-- Solution Section -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4">Solution</h2>
            
            <!-- Python Solution -->
            <div id="python" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Python Solution</h3>
                <pre class="language-python"><code>class Solution:
    def maxSlidingWindow(self, nums: List[int], k: int) -> List[int]:
        # Use deque to store indices of potential maximum values
        deque = collections.deque()
        result = []
        
        for i in range(len(nums)):
            # Remove indices that are out of the current window
            while deque and deque[0] < i - k + 1:
                deque.popleft()
                
            # Remove indices whose values are less than the current value
            while deque and nums[deque[-1]] < nums[i]:
                deque.pop()
                
            # Add current index
            deque.append(i)
            
            # Add maximum of current window to result
            if i >= k - 1:
                result.append(nums[deque[0]])
                
        return result</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(n)</h4>
                    <p class="text-gray-700">Each element is pushed and popped at most once.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(k)</h4>
                    <p class="text-gray-700">The deque stores at most k elements.</p>
                </div>
            </div>

            <!-- Java Solution -->
            <div id="java" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Java Solution</h3>
                <pre class="language-java"><code>class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        // Use deque to store indices of potential maximum values
        Deque<Integer> deque = new ArrayDeque<>();
        int[] result = new int[nums.length - k + 1];
        int j = 0;
        
        for (int i = 0; i < nums.length; i++) {
            // Remove indices that are out of the current window
            while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
                deque.pollFirst();
            }
            
            // Remove indices whose values are less than the current value
            while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
                deque.pollLast();
            }
            
            // Add current index
            deque.offerLast(i);
            
            // Add maximum of current window to result
            if (i >= k - 1) {
                result[j++] = nums[deque.peekFirst()];
            }
        }
        
        return result;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(n)</h4>
                    <p class="text-gray-700">Each element is pushed and popped at most once.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(k)</h4>
                    <p class="text-gray-700">The deque stores at most k elements.</p>
                </div>
            </div>

            <!-- C++ Solution -->
            <div id="cpp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C++ Solution</h3>
                <pre class="language-cpp"><code>class Solution {
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        // Use deque to store indices of potential maximum values
        deque<int> deque;
        vector<int> result;
        
        for (int i = 0; i < nums.size(); i++) {
            // Remove indices that are out of the current window
            while (!deque.empty() && deque.front() < i - k + 1) {
                deque.pop_front();
            }
            
            // Remove indices whose values are less than the current value
            while (!deque.empty() && nums[deque.back()] < nums[i]) {
                deque.pop_back();
            }
            
            // Add current index
            deque.push_back(i);
            
            // Add maximum of current window to result
            if (i >= k - 1) {
                result.push_back(nums[deque.front()]);
            }
        }
        
        return result;
    }
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(n)</h4>
                    <p class="text-gray-700">Each element is pushed and popped at most once.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(k)</h4>
                    <p class="text-gray-700">The deque stores at most k elements.</p>
                </div>
            </div>

            <!-- JavaScript Solution -->
            <div id="javascript" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">JavaScript Solution</h3>
                <pre class="language-javascript"><code>/**
 * @param {number[]} nums
 * @param {number} k
 * @return {number[]}
 */
var maxSlidingWindow = function(nums, k) {
    // Use array as deque to store indices of potential maximum values
    const deque = [];
    const result = [];
    
    for (let i = 0; i < nums.length; i++) {
        // Remove indices that are out of the current window
        while (deque.length && deque[0] < i - k + 1) {
            deque.shift();
        }
        
        // Remove indices whose values are less than the current value
        while (deque.length && nums[deque[deque.length - 1]] < nums[i]) {
            deque.pop();
        }
        
        // Add current index
        deque.push(i);
        
        // Add maximum of current window to result
        if (i >= k - 1) {
            result.push(nums[deque[0]]);
        }
    }
    
    return result;
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(n)</h4>
                    <p class="text-gray-700">Each element is pushed and popped at most once.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(k)</h4>
                    <p class="text-gray-700">The deque stores at most k elements.</p>
                </div>
            </div>

            <!-- C# Solution -->
            <div id="csharp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C# Solution</h3>
                <pre class="language-csharp"><code>public class Solution {
    public int[] MaxSlidingWindow(int[] nums, int k) {
        // Use LinkedList as deque to store indices of potential maximum values
        LinkedList<int> deque = new LinkedList<int>();
        int[] result = new int[nums.Length - k + 1];
        int j = 0;
        
        for (int i = 0; i < nums.Length; i++) {
            // Remove indices that are out of the current window
            while (deque.Count > 0 && deque.First.Value < i - k + 1) {
                deque.RemoveFirst();
            }
            
            // Remove indices whose values are less than the current value
            while (deque.Count > 0 && nums[deque.Last.Value] < nums[i]) {
                deque.RemoveLast();
            }
            
            // Add current index
            deque.AddLast(i);
            
            // Add maximum of current window to result
            if (i >= k - 1) {
                result[j++] = nums[deque.First.Value];
            }
        }
        
        return result;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(n)</h4>
                    <p class="text-gray-700">Each element is pushed and popped at most once.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(k)</h4>
                    <p class="text-gray-700">The deque stores at most k elements.</p>
                </div>
            </div>
        </div>

        <!-- Approach Explanation -->
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h2 class="text-2xl font-bold mb-4">Approach Explanation</h2>
            
            <div class="space-y-4">
                <p class="text-gray-700">
                    The solution uses a monotonic deque (double-ended queue) to efficiently find the maximum in each window:
                </p>
                
                <ol class="list-decimal list-inside text-gray-700 ml-4">
                    <li>Key Insight:
                        <ul class="list-disc list-inside ml-8">
                            <li>Maintain a deque of indices where corresponding values are in decreasing order</li>
                            <li>Front of deque always contains the maximum value's index</li>
                            <li>Remove elements that can't be maximum in current window</li>
                        </ul>
                    </li>
                    <li>Steps for each element:
                        <ul class="list-disc list-inside ml-8">
                            <li>Remove indices outside current window</li>
                            <li>Remove indices with smaller values</li>
                            <li>Add current index</li>
                            <li>Add maximum to result if window is complete</li>
                        </ul>
                    </li>
                </ol>

                <p class="text-gray-700 mt-4">
                    Example walkthrough for [1,3,-1,-3,5,3,6,7] with k=3:
                    <ul class="list-disc list-inside ml-4">
                        <li>After [1]: deque=[0]</li>
                        <li>After [1,3]: deque=[1]</li>
                        <li>After [1,3,-1]: deque=[1,2], output=[3]</li>
                        <li>After [3,-1,-3]: deque=[1,2,3], output=[3,3]</li>
                        <li>After [-1,-3,5]: deque=[4], output=[3,3,5]</li>
                        <li>And so on...</li>
                    </ul>
                </p>

                <p class="text-gray-700 mt-4">
                    Key insights:
                    <ul class="list-disc list-inside ml-4">
                        <li>Monotonic deque maintains potential maximums</li>
                        <li>Linear time complexity despite window size</li>
                        <li>Space complexity proportional to window size</li>
                        <li>Works well with both increasing and decreasing sequences</li>
                    </ul>
                </p>
            </div>
        </div>
    </main>

    <footer class="bg-gray-800 text-white p-4 mt-8">
        <div class="container mx-auto text-center">
            <p>© 2024 LeetCodee. All rights reserved.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html> 