<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimum Genetic Mutation - LeetCodee Solution</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body class="bg-gray-100">
    <header class="bg-gray-800 text-white p-4">
        <div class="container mx-auto">
            <a href="/" class="text-xl font-bold">LeetCodee</a>
        </div>
    </header>

    <main class="container mx-auto p-4">
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h1 class="text-3xl font-bold mb-4">433. Minimum Genetic Mutation</h1>

            <div class="solution-nav mb-6">
                Jump to Solution:
                <a href="#python" class="ml-2 text-blue-600 hover:text-blue-800">Python</a>
                <a href="#java" class="ml-2 text-blue-600 hover:text-blue-800">Java</a>
                <a href="#cpp" class="ml-2 text-blue-600 hover:text-blue-800">C++</a>
                <a href="#javascript" class="ml-2 text-blue-600 hover:text-blue-800">JavaScript</a>
                <a href="#csharp" class="ml-2 text-blue-600 hover:text-blue-800">C#</a>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Problem Description</h2>
                <p class="text-gray-700 mb-4">
                    A gene string can be represented by an 8-character long string, with choices from <code class="bg-gray-100 px-1 rounded">'A'</code>, <code class="bg-gray-100 px-1 rounded">'C'</code>, <code class="bg-gray-100 px-1 rounded">'G'</code>, and <code class="bg-gray-100 px-1 rounded">'T'</code>.
                </p>
                <p class="text-gray-700 mb-4">
                    Suppose we need to investigate a mutation from a gene string <code class="bg-gray-100 px-1 rounded">startGene</code> to a gene string <code class="bg-gray-100 px-1 rounded">endGene</code> where one mutation is defined as one single character changed in the gene string.
                </p>
                <p class="text-gray-700 mb-4">
                    For example, <code class="bg-gray-100 px-1 rounded">"AACCGGTT" -> "AACCGGTA"</code> is one mutation.
                </p>
                <p class="text-gray-700 mb-4">
                    There is also a gene bank <code class="bg-gray-100 px-1 rounded">bank</code> that records all the valid gene mutations. A gene must be in <code class="bg-gray-100 px-1 rounded">bank</code> to make it a valid gene string.
                </p>
                <p class="text-gray-700 mb-4">
                    Given the two gene strings <code class="bg-gray-100 px-1 rounded">startGene</code> and <code class="bg-gray-100 px-1 rounded">endGene</code> and the gene bank <code class="bg-gray-100 px-1 rounded">bank</code>, return the minimum number of mutations needed to mutate from <code class="bg-gray-100 px-1 rounded">startGene</code> to <code class="bg-gray-100 px-1 rounded">endGene</code>. If there is no such a mutation, return <code class="bg-gray-100 px-1 rounded">-1</code>.
                </p>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 1:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: startGene = "AACCGGTT", endGene = "AACCGGTA", bank = ["AACCGGTA"]
Output: 1</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Example 2:</h2>
                <pre class="bg-gray-100 p-4 rounded"><code>Input: startGene = "AAAAACCC", endGene = "AACCCCCC", bank = ["AAAAAACC","CCCCCCCC","AACCCCCC","AAACCCCC"]
Output: 3</code></pre>
            </div>

            <div class="mb-6">
                <h2 class="text-xl font-semibold mb-2">Constraints:</h2>
                <ul class="list-disc list-inside text-gray-700">
                    <li><code class="bg-gray-100 px-1 rounded">0 <= bank.length <= 10</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">startGene.length == endGene.length == 8</code></li>
                    <li><code class="bg-gray-100 px-1 rounded">startGene</code>, <code class="bg-gray-100 px-1 rounded">endGene</code>, and all strings in <code class="bg-gray-100 px-1 rounded">bank</code> consist of only the characters <code class="bg-gray-100 px-1 rounded">['A', 'C', 'G', 'T']</code></li>
                </ul>
            </div>
        </div>

        <!-- Solution Section -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 class="text-2xl font-bold mb-4">Solution</h2>
            
            <!-- Python Solution -->
            <div id="python" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Python Solution</h3>
                <pre class="language-python"><code>class Solution:
    def minMutation(self, startGene: str, endGene: str, bank: List[str]) -> int:
        # Convert bank to set for O(1) lookup
        bank = set(bank)
        if endGene not in bank:
            return -1
            
        # Valid characters for mutation
        chars = ['A', 'C', 'G', 'T']
        
        # BFS queue with gene string and mutations count
        queue = deque([(startGene, 0)])
        seen = {startGene}
        
        while queue:
            gene, mutations = queue.popleft()
            
            if gene == endGene:
                return mutations
            
            # Try all possible mutations
            for i in range(8):
                for c in chars:
                    if c != gene[i]:
                        newGene = gene[:i] + c + gene[i+1:]
                        if newGene in bank and newGene not in seen:
                            queue.append((newGene, mutations + 1))
                            seen.add(newGene)
        
        return -1</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(N * L * 4)</h4>
                    <p class="text-gray-700">Where N is the length of the gene string (8) and L is the size of the bank. For each position, we try 3 other characters.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(L)</h4>
                    <p class="text-gray-700">For storing the bank set and visited genes.</p>
                </div>
            </div>

            <!-- Java Solution -->
            <div id="java" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">Java Solution</h3>
                <pre class="language-java"><code>class Solution {
    public int minMutation(String startGene, String endGene, String[] bank) {
        // Convert bank to set for O(1) lookup
        Set<String> bankSet = new HashSet<>(Arrays.asList(bank));
        if (!bankSet.contains(endGene)) {
            return -1;
        }
        
        // Valid characters for mutation
        char[] chars = {'A', 'C', 'G', 'T'};
        
        // BFS queue with gene string and mutations count
        Queue<String> queue = new LinkedList<>();
        queue.offer(startGene);
        Set<String> seen = new HashSet<>();
        seen.add(startGene);
        int mutations = 0;
        
        while (!queue.isEmpty()) {
            int size = queue.size();
            
            for (int i = 0; i < size; i++) {
                String gene = queue.poll();
                
                if (gene.equals(endGene)) {
                    return mutations;
                }
                
                // Try all possible mutations
                char[] geneArray = gene.toCharArray();
                for (int j = 0; j < 8; j++) {
                    char original = geneArray[j];
                    for (char c : chars) {
                        if (c != original) {
                            geneArray[j] = c;
                            String newGene = new String(geneArray);
                            if (bankSet.contains(newGene) && !seen.contains(newGene)) {
                                queue.offer(newGene);
                                seen.add(newGene);
                            }
                        }
                    }
                    geneArray[j] = original;
                }
            }
            mutations++;
        }
        
        return -1;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(N * L * 4)</h4>
                    <p class="text-gray-700">Where N is the length of the gene string (8) and L is the size of the bank. For each position, we try 3 other characters.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(L)</h4>
                    <p class="text-gray-700">For storing the bank set and visited genes.</p>
                </div>
            </div>

            <!-- C++ Solution -->
            <div id="cpp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C++ Solution</h3>
                <pre class="language-cpp"><code>class Solution {
public:
    int minMutation(string startGene, string endGene, vector<string>& bank) {
        // Convert bank to set for O(1) lookup
        unordered_set<string> bankSet(bank.begin(), bank.end());
        if (bankSet.find(endGene) == bankSet.end()) {
            return -1;
        }
        
        // Valid characters for mutation
        vector<char> chars = {'A', 'C', 'G', 'T'};
        
        // BFS queue with gene string and mutations count
        queue<string> q;
        q.push(startGene);
        unordered_set<string> seen;
        seen.insert(startGene);
        int mutations = 0;
        
        while (!q.empty()) {
            int size = q.size();
            
            for (int i = 0; i < size; i++) {
                string gene = q.front();
                q.pop();
                
                if (gene == endGene) {
                    return mutations;
                }
                
                // Try all possible mutations
                for (int j = 0; j < 8; j++) {
                    char original = gene[j];
                    for (char c : chars) {
                        if (c != original) {
                            gene[j] = c;
                            if (bankSet.find(gene) != bankSet.end() && 
                                seen.find(gene) == seen.end()) {
                                q.push(gene);
                                seen.insert(gene);
                            }
                        }
                    }
                    gene[j] = original;
                }
            }
            mutations++;
        }
        
        return -1;
    }
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(N * L * 4)</h4>
                    <p class="text-gray-700">Where N is the length of the gene string (8) and L is the size of the bank. For each position, we try 3 other characters.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(L)</h4>
                    <p class="text-gray-700">For storing the bank set and visited genes.</p>
                </div>
            </div>

            <!-- JavaScript Solution -->
            <div id="javascript" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">JavaScript Solution</h3>
                <pre class="language-javascript"><code>/**
 * @param {string} startGene
 * @param {string} endGene
 * @param {string[]} bank
 * @return {number}
 */
var minMutation = function(startGene, endGene, bank) {
    // Convert bank to set for O(1) lookup
    const bankSet = new Set(bank);
    if (!bankSet.has(endGene)) {
        return -1;
    }
    
    // Valid characters for mutation
    const chars = ['A', 'C', 'G', 'T'];
    
    // BFS queue with gene string and mutations count
    const queue = [[startGene, 0]];
    const seen = new Set([startGene]);
    
    while (queue.length) {
        const [gene, mutations] = queue.shift();
        
        if (gene === endGene) {
            return mutations;
        }
        
        // Try all possible mutations
        for (let i = 0; i < 8; i++) {
            for (const c of chars) {
                if (c !== gene[i]) {
                    const newGene = gene.slice(0, i) + c + gene.slice(i + 1);
                    if (bankSet.has(newGene) && !seen.has(newGene)) {
                        queue.push([newGene, mutations + 1]);
                        seen.add(newGene);
                    }
                }
            }
        }
    }
    
    return -1;
};</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(N * L * 4)</h4>
                    <p class="text-gray-700">Where N is the length of the gene string (8) and L is the size of the bank. For each position, we try 3 other characters.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(L)</h4>
                    <p class="text-gray-700">For storing the bank set and visited genes.</p>
                </div>
            </div>

            <!-- C# Solution -->
            <div id="csharp" class="mb-8">
                <h3 class="text-xl font-semibold mb-4">C# Solution</h3>
                <pre class="language-csharp"><code>public class Solution {
    public int MinMutation(string startGene, string endGene, string[] bank) {
        // Convert bank to set for O(1) lookup
        HashSet<string> bankSet = new HashSet<string>(bank);
        if (!bankSet.Contains(endGene)) {
            return -1;
        }
        
        // Valid characters for mutation
        char[] chars = {'A', 'C', 'G', 'T'};
        
        // BFS queue with gene string and mutations count
        Queue<string> queue = new Queue<string>();
        queue.Enqueue(startGene);
        HashSet<string> seen = new HashSet<string>();
        seen.Add(startGene);
        int mutations = 0;
        
        while (queue.Count > 0) {
            int size = queue.Count;
            
            for (int i = 0; i < size; i++) {
                string gene = queue.Dequeue();
                
                if (gene == endGene) {
                    return mutations;
                }
                
                // Try all possible mutations
                char[] geneArray = gene.ToCharArray();
                for (int j = 0; j < 8; j++) {
                    char original = geneArray[j];
                    foreach (char c in chars) {
                        if (c != original) {
                            geneArray[j] = c;
                            string newGene = new string(geneArray);
                            if (bankSet.Contains(newGene) && !seen.Contains(newGene)) {
                                queue.Enqueue(newGene);
                                seen.Add(newGene);
                            }
                        }
                    }
                    geneArray[j] = original;
                }
            }
            mutations++;
        }
        
        return -1;
    }
}</code></pre>
                
                <div class="mt-4">
                    <h4 class="text-lg font-semibold mb-2">Time Complexity: O(N * L * 4)</h4>
                    <p class="text-gray-700">Where N is the length of the gene string (8) and L is the size of the bank. For each position, we try 3 other characters.</p>
                    
                    <h4 class="text-lg font-semibold mb-2 mt-4">Space Complexity: O(L)</h4>
                    <p class="text-gray-700">For storing the bank set and visited genes.</p>
                </div>
            </div>
        </div>

        <!-- Approach Explanation -->
        <div class="bg-white rounded-lg shadow-lg p-6">
            <h2 class="text-2xl font-bold mb-4">Approach Explanation</h2>
            
            <div class="space-y-4">
                <p class="text-gray-700">
                    The solution uses a breadth-first search (BFS) approach:
                </p>
                
                <ol class="list-decimal list-inside text-gray-700 ml-4">
                    <li>Key Insights:
                        <ul class="list-disc list-inside ml-8">
                            <li>BFS for shortest path</li>
                            <li>Character mutations</li>
                            <li>Valid gene tracking</li>
                            <li>Visited state handling</li>
                        </ul>
                    </li>
                    <li>Algorithm Steps:
                        <ul class="list-disc list-inside ml-8">
                            <li>Initialize structures</li>
                            <li>Process mutations</li>
                            <li>Track visited</li>
                            <li>Find shortest path</li>
                        </ul>
                    </li>
                </ol>

                <p class="text-gray-700 mt-4">
                    Implementation Details:
                    <ul class="list-disc list-inside ml-4">
                        <li>Queue operations</li>
                        <li>String manipulation</li>
                        <li>Set operations</li>
                        <li>Path tracking</li>
                    </ul>
                </p>

                <p class="text-gray-700 mt-4">
                    Optimization Insights:
                    <ul class="list-disc list-inside ml-4">
                        <li>Early validation</li>
                        <li>Efficient lookup</li>
                        <li>State pruning</li>
                        <li>Memory management</li>
                    </ul>
                </p>

                <p class="text-gray-700 mt-4">
                    Edge Cases:
                    <ul class="list-disc list-inside ml-4">
                        <li>Invalid end gene</li>
                        <li>No valid path</li>
                        <li>Single mutation</li>
                        <li>Multiple paths</li>
                    </ul>
                </p>
            </div>
        </div>
    </main>

    <footer class="bg-gray-800 text-white p-4 mt-8">
        <div class="container mx-auto text-center">
            <p>Â© 2024 LeetCodee. All rights reserved.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.24.1/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html> 